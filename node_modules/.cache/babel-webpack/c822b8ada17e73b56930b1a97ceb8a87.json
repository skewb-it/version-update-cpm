{"ast":null,"code":"import { ComponentPortal, TemplatePortal, PortalModule } from '@angular/cdk/portal';\nimport { InjectionToken, EventEmitter, Component, ViewEncapsulation, ChangeDetectionStrategy, ElementRef, NgZone, Input, Output, Injectable, ChangeDetectorRef, Optional, Inject, ViewChild, forwardRef, ViewContainerRef, ContentChild, TemplateRef, Directive, NgModule } from '@angular/core';\nimport { DateRange, MatDatepickerIntl, matDatepickerAnimations, MAT_DATEPICKER_SCROLL_STRATEGY, MatDatepickerModule, MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER } from '@angular/material/datepicker';\nimport { Subscription, Subject, merge } from 'rxjs';\nimport { DateAdapter, mixinColor, MAT_DATE_LOCALE } from '@angular/material/core';\nimport { ESCAPE, SPACE, ENTER, PAGE_DOWN, PAGE_UP, END, HOME, DOWN_ARROW, UP_ARROW, RIGHT_ARROW, LEFT_ARROW } from '@angular/cdk/keycodes';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { take, startWith, takeUntil, debounceTime, filter } from 'rxjs/operators';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { OverlayConfig, Overlay } from '@angular/cdk/overlay';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { MatDialog, MatDialogModule } from '@angular/material/dialog';\nimport { Validators, NG_VALUE_ACCESSOR, FormBuilder, NG_VALIDATORS, ReactiveFormsModule, FormsModule } from '@angular/forms';\nimport { MatFormField } from '@angular/material/form-field';\nimport { MAT_INPUT_VALUE_ACCESSOR, MatInputModule } from '@angular/material/input';\nimport { MatButtonModule } from '@angular/material/button';\nimport { MatIconModule } from '@angular/material/icon';\nimport { Platform, PlatformModule } from '@angular/cdk/platform';\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: lib/core/date-adapter.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @abstract\r\n * @template D\r\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nimport * as ɵngcc2 from '@angular/cdk/bidi';\nimport * as ɵngcc3 from '@angular/material/datepicker';\nimport * as ɵngcc4 from '@angular/material/button';\nimport * as ɵngcc5 from '@angular/cdk/portal';\nimport * as ɵngcc6 from '@angular/forms';\nimport * as ɵngcc7 from '@angular/material/form-field';\nimport * as ɵngcc8 from '@angular/material/input';\nimport * as ɵngcc9 from '@angular/material/icon';\nimport * as ɵngcc10 from '@angular/material/dialog';\nimport * as ɵngcc11 from '@angular/cdk/overlay';\nimport * as ɵngcc12 from '@angular/cdk/platform';\nconst _c0 = [\"ngx-mat-calendar-body\", \"\"];\n\nfunction NgxMatCalendarBody_tr_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"tr\", 2);\n    ɵngcc0.ɵɵelementStart(1, \"td\", 3);\n    ɵngcc0.ɵɵtext(2);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵstyleProp(\"padding-top\", ctx_r0._cellPadding)(\"padding-bottom\", ctx_r0._cellPadding);\n    ɵngcc0.ɵɵattribute(\"colspan\", ctx_r0.numCols);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", ctx_r0.label, \" \");\n  }\n}\n\nfunction NgxMatCalendarBody_tr_1_td_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"td\", 7);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵstyleProp(\"padding-top\", ctx_r4._cellPadding)(\"padding-bottom\", ctx_r4._cellPadding);\n    ɵngcc0.ɵɵattribute(\"colspan\", ctx_r4._firstRowOffset);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", ctx_r4._firstRowOffset >= ctx_r4.labelMinRequiredCells ? ctx_r4.label : \"\", \" \");\n  }\n}\n\nfunction NgxMatCalendarBody_tr_1_td_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r9 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"td\", 8);\n    ɵngcc0.ɵɵlistener(\"click\", function NgxMatCalendarBody_tr_1_td_2_Template_td_click_0_listener($event) {\n      const restoredCtx = ɵngcc0.ɵɵrestoreView(_r9);\n      const item_r6 = restoredCtx.$implicit;\n      const ctx_r8 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r8._cellClicked(item_r6, $event);\n    });\n    ɵngcc0.ɵɵelementStart(1, \"div\", 9);\n    ɵngcc0.ɵɵtext(2);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelement(3, \"div\", 10);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const item_r6 = ctx.$implicit;\n    const colIndex_r7 = ctx.index;\n    const rowIndex_r3 = ɵngcc0.ɵɵnextContext().index;\n    const ctx_r5 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵstyleProp(\"width\", ctx_r5._cellWidth)(\"padding-top\", ctx_r5._cellPadding)(\"padding-bottom\", ctx_r5._cellPadding);\n    ɵngcc0.ɵɵclassProp(\"mat-calendar-body-disabled\", !item_r6.enabled)(\"mat-calendar-body-active\", ctx_r5._isActiveCell(rowIndex_r3, colIndex_r7))(\"mat-calendar-body-range-start\", ctx_r5._isRangeStart(item_r6.compareValue))(\"mat-calendar-body-range-end\", ctx_r5._isRangeEnd(item_r6.compareValue))(\"mat-calendar-body-in-range\", ctx_r5._isInRange(item_r6.compareValue))(\"mat-calendar-body-comparison-bridge-start\", ctx_r5._isComparisonBridgeStart(item_r6.compareValue, rowIndex_r3, colIndex_r7))(\"mat-calendar-body-comparison-bridge-end\", ctx_r5._isComparisonBridgeEnd(item_r6.compareValue, rowIndex_r3, colIndex_r7))(\"mat-calendar-body-comparison-start\", ctx_r5._isComparisonStart(item_r6.compareValue))(\"mat-calendar-body-comparison-end\", ctx_r5._isComparisonEnd(item_r6.compareValue))(\"mat-calendar-body-in-comparison-range\", ctx_r5._isInComparisonRange(item_r6.compareValue))(\"mat-calendar-body-preview-start\", ctx_r5._isPreviewStart(item_r6.compareValue))(\"mat-calendar-body-preview-end\", ctx_r5._isPreviewEnd(item_r6.compareValue))(\"mat-calendar-body-in-preview\", ctx_r5._isInPreview(item_r6.compareValue));\n    ɵngcc0.ɵɵproperty(\"ngClass\", item_r6.cssClasses)(\"tabindex\", ctx_r5._isActiveCell(rowIndex_r3, colIndex_r7) ? 0 : -1);\n    ɵngcc0.ɵɵattribute(\"data-mat-row\", rowIndex_r3)(\"data-mat-col\", colIndex_r7)(\"aria-label\", item_r6.ariaLabel)(\"aria-disabled\", !item_r6.enabled || null)(\"aria-selected\", ctx_r5._isSelected(item_r6));\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵclassProp(\"mat-calendar-body-selected\", ctx_r5._isSelected(item_r6))(\"mat-calendar-body-today\", ctx_r5.todayValue === item_r6.compareValue);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", item_r6.displayValue, \" \");\n  }\n}\n\nfunction NgxMatCalendarBody_tr_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"tr\", 4);\n    ɵngcc0.ɵɵtemplate(1, NgxMatCalendarBody_tr_1_td_1_Template, 2, 6, \"td\", 5);\n    ɵngcc0.ɵɵtemplate(2, NgxMatCalendarBody_tr_1_td_2_Template, 4, 44, \"td\", 6);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const row_r2 = ctx.$implicit;\n    const rowIndex_r3 = ctx.index;\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", rowIndex_r3 === 0 && ctx_r1._firstRowOffset);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", row_r2);\n  }\n}\n\nfunction NgxMatMonthView_th_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"th\", 5);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const day_r1 = ctx.$implicit;\n    ɵngcc0.ɵɵattribute(\"aria-label\", day_r1.long);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(day_r1.narrow);\n  }\n}\n\nconst _c1 = [\"*\"];\n\nfunction NgxMatCalendar_ng_template_0_Template(rf, ctx) {}\n\nfunction NgxMatCalendar_ngx_mat_month_view_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"ngx-mat-month-view\", 5);\n    ɵngcc0.ɵɵlistener(\"activeDateChange\", function NgxMatCalendar_ngx_mat_month_view_2_Template_ngx_mat_month_view_activeDateChange_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r5);\n      const ctx_r4 = ɵngcc0.ɵɵnextContext();\n      return ctx_r4.activeDate = $event;\n    })(\"selectedChange\", function NgxMatCalendar_ngx_mat_month_view_2_Template_ngx_mat_month_view_selectedChange_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r5);\n      const ctx_r6 = ɵngcc0.ɵɵnextContext();\n      return ctx_r6._dateSelected($event);\n    })(\"_userSelection\", function NgxMatCalendar_ngx_mat_month_view_2_Template_ngx_mat_month_view__userSelection_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r5);\n      const ctx_r7 = ɵngcc0.ɵɵnextContext();\n      return ctx_r7._userSelected();\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"activeDate\", ctx_r1.activeDate)(\"selected\", ctx_r1.selected)(\"dateFilter\", ctx_r1.dateFilter)(\"maxDate\", ctx_r1.maxDate)(\"minDate\", ctx_r1.minDate)(\"dateClass\", ctx_r1.dateClass);\n  }\n}\n\nfunction NgxMatCalendar_ngx_mat_year_view_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r9 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"ngx-mat-year-view\", 6);\n    ɵngcc0.ɵɵlistener(\"activeDateChange\", function NgxMatCalendar_ngx_mat_year_view_3_Template_ngx_mat_year_view_activeDateChange_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r9);\n      const ctx_r8 = ɵngcc0.ɵɵnextContext();\n      return ctx_r8.activeDate = $event;\n    })(\"monthSelected\", function NgxMatCalendar_ngx_mat_year_view_3_Template_ngx_mat_year_view_monthSelected_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r9);\n      const ctx_r10 = ɵngcc0.ɵɵnextContext();\n      return ctx_r10._monthSelectedInYearView($event);\n    })(\"selectedChange\", function NgxMatCalendar_ngx_mat_year_view_3_Template_ngx_mat_year_view_selectedChange_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r9);\n      const ctx_r11 = ɵngcc0.ɵɵnextContext();\n      return ctx_r11._goToDateInView($event, \"month\");\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"activeDate\", ctx_r2.activeDate)(\"selected\", ctx_r2.selected)(\"dateFilter\", ctx_r2.dateFilter)(\"maxDate\", ctx_r2.maxDate)(\"minDate\", ctx_r2.minDate);\n  }\n}\n\nfunction NgxMatCalendar_ngx_mat_multi_year_view_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r13 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"ngx-mat-multi-year-view\", 7);\n    ɵngcc0.ɵɵlistener(\"activeDateChange\", function NgxMatCalendar_ngx_mat_multi_year_view_4_Template_ngx_mat_multi_year_view_activeDateChange_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r13);\n      const ctx_r12 = ɵngcc0.ɵɵnextContext();\n      return ctx_r12.activeDate = $event;\n    })(\"yearSelected\", function NgxMatCalendar_ngx_mat_multi_year_view_4_Template_ngx_mat_multi_year_view_yearSelected_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r13);\n      const ctx_r14 = ɵngcc0.ɵɵnextContext();\n      return ctx_r14._yearSelectedInMultiYearView($event);\n    })(\"selectedChange\", function NgxMatCalendar_ngx_mat_multi_year_view_4_Template_ngx_mat_multi_year_view_selectedChange_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r13);\n      const ctx_r15 = ɵngcc0.ɵɵnextContext();\n      return ctx_r15._goToDateInView($event, \"year\");\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"activeDate\", ctx_r3.activeDate)(\"selected\", ctx_r3.selected)(\"dateFilter\", ctx_r3.dateFilter)(\"maxDate\", ctx_r3.maxDate)(\"minDate\", ctx_r3.minDate);\n  }\n}\n\nfunction NgxMatTimepickerComponent_tr_3_td_11_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r10 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"td\");\n    ɵngcc0.ɵɵelementStart(1, \"button\", 10);\n    ɵngcc0.ɵɵlistener(\"click\", function NgxMatTimepickerComponent_tr_3_td_11_Template_button_click_1_listener() {\n      ɵngcc0.ɵɵrestoreView(_r10);\n      const ctx_r9 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r9.change(\"second\", true);\n    });\n    ɵngcc0.ɵɵelementStart(2, \"mat-icon\");\n    ɵngcc0.ɵɵtext(3, \"expand_less\");\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"disabled\", ctx_r6.disabled || ctx_r6.disableMinute);\n  }\n}\n\nfunction NgxMatTimepickerComponent_tr_3_td_12_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"td\", 6);\n  }\n}\n\nfunction NgxMatTimepickerComponent_tr_3_td_13_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"td\");\n  }\n}\n\nfunction NgxMatTimepickerComponent_tr_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r12 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"tr\");\n    ɵngcc0.ɵɵelementStart(1, \"td\");\n    ɵngcc0.ɵɵelementStart(2, \"button\", 10);\n    ɵngcc0.ɵɵlistener(\"click\", function NgxMatTimepickerComponent_tr_3_Template_button_click_2_listener() {\n      ɵngcc0.ɵɵrestoreView(_r12);\n      const ctx_r11 = ɵngcc0.ɵɵnextContext();\n      return ctx_r11.change(\"hour\", true);\n    });\n    ɵngcc0.ɵɵelementStart(3, \"mat-icon\");\n    ɵngcc0.ɵɵtext(4, \"expand_less\");\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelement(5, \"td\");\n    ɵngcc0.ɵɵelementStart(6, \"td\");\n    ɵngcc0.ɵɵelementStart(7, \"button\", 10);\n    ɵngcc0.ɵɵlistener(\"click\", function NgxMatTimepickerComponent_tr_3_Template_button_click_7_listener() {\n      ɵngcc0.ɵɵrestoreView(_r12);\n      const ctx_r13 = ɵngcc0.ɵɵnextContext();\n      return ctx_r13.change(\"minute\", true);\n    });\n    ɵngcc0.ɵɵelementStart(8, \"mat-icon\");\n    ɵngcc0.ɵɵtext(9, \"expand_less\");\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelement(10, \"td\");\n    ɵngcc0.ɵɵtemplate(11, NgxMatTimepickerComponent_tr_3_td_11_Template, 4, 1, \"td\", 3);\n    ɵngcc0.ɵɵtemplate(12, NgxMatTimepickerComponent_tr_3_td_12_Template, 1, 0, \"td\", 8);\n    ɵngcc0.ɵɵtemplate(13, NgxMatTimepickerComponent_tr_3_td_13_Template, 1, 0, \"td\", 3);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"disabled\", ctx_r0.disabled);\n    ɵngcc0.ɵɵadvance(5);\n    ɵngcc0.ɵɵproperty(\"disabled\", ctx_r0.disabled || ctx_r0.disableMinute);\n    ɵngcc0.ɵɵadvance(4);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r0.showSeconds);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r0.enableMeridian);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r0.enableMeridian);\n  }\n}\n\nfunction NgxMatTimepickerComponent_td_13_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"td\", 6);\n    ɵngcc0.ɵɵtext(1, \":\");\n    ɵngcc0.ɵɵelementEnd();\n  }\n}\n\nfunction NgxMatTimepickerComponent_td_14_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r15 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"td\");\n    ɵngcc0.ɵɵelementStart(1, \"mat-form-field\", 4);\n    ɵngcc0.ɵɵelementStart(2, \"input\", 11);\n    ɵngcc0.ɵɵlistener(\"input\", function NgxMatTimepickerComponent_td_14_Template_input_input_2_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r15);\n      const ctx_r14 = ɵngcc0.ɵɵnextContext();\n      return ctx_r14.formatInput($event.target);\n    })(\"keydown.ArrowUp\", function NgxMatTimepickerComponent_td_14_Template_input_keydown_ArrowUp_2_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r15);\n      const ctx_r16 = ɵngcc0.ɵɵnextContext();\n      ctx_r16.change(\"second\", true);\n      return $event.preventDefault();\n    })(\"keydown.ArrowDown\", function NgxMatTimepickerComponent_td_14_Template_input_keydown_ArrowDown_2_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r15);\n      const ctx_r17 = ɵngcc0.ɵɵnextContext();\n      ctx_r17.change(\"second\", false);\n      return $event.preventDefault();\n    })(\"blur\", function NgxMatTimepickerComponent_td_14_Template_input_blur_2_listener() {\n      ɵngcc0.ɵɵrestoreView(_r15);\n      const ctx_r18 = ɵngcc0.ɵɵnextContext();\n      return ctx_r18.change(\"second\");\n    });\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n}\n\nfunction NgxMatTimepickerComponent_td_15_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"td\", 6);\n  }\n}\n\nfunction NgxMatTimepickerComponent_td_16_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r20 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"td\", 12);\n    ɵngcc0.ɵɵelementStart(1, \"button\", 13);\n    ɵngcc0.ɵɵlistener(\"click\", function NgxMatTimepickerComponent_td_16_Template_button_click_1_listener() {\n      ɵngcc0.ɵɵrestoreView(_r20);\n      const ctx_r19 = ɵngcc0.ɵɵnextContext();\n      return ctx_r19.toggleMeridian();\n    });\n    ɵngcc0.ɵɵtext(2);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"color\", ctx_r4.color)(\"disabled\", ctx_r4.disabled);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", ctx_r4.meridian, \" \");\n  }\n}\n\nfunction NgxMatTimepickerComponent_tr_17_td_10_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"td\");\n  }\n}\n\nfunction NgxMatTimepickerComponent_tr_17_td_11_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r26 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"td\");\n    ɵngcc0.ɵɵelementStart(1, \"button\", 14);\n    ɵngcc0.ɵɵlistener(\"click\", function NgxMatTimepickerComponent_tr_17_td_11_Template_button_click_1_listener() {\n      ɵngcc0.ɵɵrestoreView(_r26);\n      const ctx_r25 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r25.change(\"second\", false);\n    });\n    ɵngcc0.ɵɵelementStart(2, \"mat-icon\");\n    ɵngcc0.ɵɵtext(3, \"expand_more\");\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r22 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"disabled\", ctx_r22.disabled || ctx_r22.disableMinute);\n  }\n}\n\nfunction NgxMatTimepickerComponent_tr_17_td_12_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"td\", 6);\n  }\n}\n\nfunction NgxMatTimepickerComponent_tr_17_td_13_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"td\");\n  }\n}\n\nfunction NgxMatTimepickerComponent_tr_17_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r28 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"tr\");\n    ɵngcc0.ɵɵelementStart(1, \"td\");\n    ɵngcc0.ɵɵelementStart(2, \"button\", 14);\n    ɵngcc0.ɵɵlistener(\"click\", function NgxMatTimepickerComponent_tr_17_Template_button_click_2_listener() {\n      ɵngcc0.ɵɵrestoreView(_r28);\n      const ctx_r27 = ɵngcc0.ɵɵnextContext();\n      return ctx_r27.change(\"hour\", false);\n    });\n    ɵngcc0.ɵɵelementStart(3, \"mat-icon\");\n    ɵngcc0.ɵɵtext(4, \"expand_more\");\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelement(5, \"td\");\n    ɵngcc0.ɵɵelementStart(6, \"td\");\n    ɵngcc0.ɵɵelementStart(7, \"button\", 14);\n    ɵngcc0.ɵɵlistener(\"click\", function NgxMatTimepickerComponent_tr_17_Template_button_click_7_listener() {\n      ɵngcc0.ɵɵrestoreView(_r28);\n      const ctx_r29 = ɵngcc0.ɵɵnextContext();\n      return ctx_r29.change(\"minute\", false);\n    });\n    ɵngcc0.ɵɵelementStart(8, \"mat-icon\");\n    ɵngcc0.ɵɵtext(9, \"expand_more\");\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵtemplate(10, NgxMatTimepickerComponent_tr_17_td_10_Template, 1, 0, \"td\", 3);\n    ɵngcc0.ɵɵtemplate(11, NgxMatTimepickerComponent_tr_17_td_11_Template, 4, 1, \"td\", 3);\n    ɵngcc0.ɵɵtemplate(12, NgxMatTimepickerComponent_tr_17_td_12_Template, 1, 0, \"td\", 8);\n    ɵngcc0.ɵɵtemplate(13, NgxMatTimepickerComponent_tr_17_td_13_Template, 1, 0, \"td\", 3);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"disabled\", ctx_r5.disabled);\n    ɵngcc0.ɵɵadvance(5);\n    ɵngcc0.ɵɵproperty(\"disabled\", ctx_r5.disabled || ctx_r5.disableMinute);\n    ɵngcc0.ɵɵadvance(3);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r5.showSeconds);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r5.showSeconds);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r5.enableMeridian);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r5.enableMeridian);\n  }\n}\n\nfunction NgxMatDatetimeContent_ng_container_1_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"div\", 6);\n    ɵngcc0.ɵɵelementStart(1, \"ngx-mat-timepicker\", 7);\n    ɵngcc0.ɵɵlistener(\"ngModelChange\", function NgxMatDatetimeContent_ng_container_1_div_1_Template_ngx_mat_timepicker_ngModelChange_1_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r5);\n      const ctx_r4 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r4.datepicker._selected = $event;\n    });\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵclassProp(\"disable-seconds\", !ctx_r1.datepicker._showSeconds);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"showSpinners\", ctx_r1.datepicker._showSpinners)(\"showSeconds\", ctx_r1.datepicker._showSeconds)(\"disabled\", ctx_r1.datepicker._disabled)(\"stepHour\", ctx_r1.datepicker._stepHour)(\"stepMinute\", ctx_r1.datepicker._stepMinute)(\"stepSecond\", ctx_r1.datepicker._stepSecond)(\"ngModel\", ctx_r1.datepicker._selected)(\"color\", ctx_r1.datepicker._color)(\"enableMeridian\", ctx_r1.datepicker._enableMeridian)(\"disableMinute\", ctx_r1.datepicker._disableMinute);\n  }\n}\n\nfunction NgxMatDatetimeContent_ng_container_1_mat_icon_4_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"mat-icon\");\n    ɵngcc0.ɵɵtext(1, \"done\");\n    ɵngcc0.ɵɵelementEnd();\n  }\n}\n\nfunction NgxMatDatetimeContent_ng_container_1_ng_template_5_Template(rf, ctx) {}\n\nfunction NgxMatDatetimeContent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtemplate(1, NgxMatDatetimeContent_ng_container_1_div_1_Template, 2, 12, \"div\", 2);\n    ɵngcc0.ɵɵelementStart(2, \"div\", 3);\n    ɵngcc0.ɵɵelementStart(3, \"button\", 4);\n    ɵngcc0.ɵɵlistener(\"click\", function NgxMatDatetimeContent_ng_container_1_Template_button_click_3_listener() {\n      ɵngcc0.ɵɵrestoreView(_r7);\n      const ctx_r6 = ɵngcc0.ɵɵnextContext();\n      return ctx_r6.datepicker.ok();\n    });\n    ɵngcc0.ɵɵtemplate(4, NgxMatDatetimeContent_ng_container_1_mat_icon_4_Template, 2, 0, \"mat-icon\", 1);\n    ɵngcc0.ɵɵtemplate(5, NgxMatDatetimeContent_ng_container_1_ng_template_5_Template, 0, 0, \"ng-template\", 5);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r0.datepicker._hideTime);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"color\", ctx_r0.datepicker._color)(\"disabled\", !ctx_r0.valid);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r0.datepicker._customIcon);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"cdkPortalOutlet\", ctx_r0._templateCustomIconPortal);\n  }\n}\n\nclass NgxMatDateAdapter extends DateAdapter {\n  /**\r\n   * Check if two date have same time\r\n   * @param {?} a Date 1\r\n   * @param {?} b Date 2\r\n   * @return {?}\r\n   */\n  isSameTime(a, b) {\n    if (a == null || b == null) return true;\n    return this.getHour(a) === this.getHour(b) && this.getMinute(a) === this.getMinute(b) && this.getSecond(a) === this.getSecond(b);\n  }\n  /**\r\n   * Copy time from a date to a another date\r\n   * @param {?} toDate\r\n   * @param {?} fromDate\r\n   * @return {?}\r\n   */\n\n\n  copyTime(toDate, fromDate) {\n    this.setHour(toDate, this.getHour(fromDate));\n    this.setMinute(toDate, this.getMinute(fromDate));\n    this.setSecond(toDate, this.getSecond(fromDate));\n  }\n  /**\r\n   * Compares two dates.\r\n   * @param {?} first The first date to compare.\r\n   * @param {?} second The second date to compare.\r\n   * @param {?=} showSeconds\r\n   * @return {?} 0 if the dates are equal, a number less than 0 if the first date is earlier,\r\n   *     a number greater than 0 if the first date is later.\r\n   */\n\n\n  compareDateWithTime(first, second, showSeconds) {\n    /** @type {?} */\n    let res = super.compareDate(first, second) || this.getHour(first) - this.getHour(second) || this.getMinute(first) - this.getMinute(second);\n\n    if (showSeconds) {\n      res = res || this.getSecond(first) - this.getSecond(second);\n    }\n\n    return res;\n  }\n  /**\r\n   * Set time by using default values\r\n   * @param {?} date\r\n   * @param {?} defaultTime List default values [hour, minute, second]\r\n   * @return {?}\r\n   */\n\n\n  setTimeByDefaultValues(date, defaultTime) {\n    if (!Array.isArray(defaultTime)) {\n      throw Error('@Input DefaultTime should be an array');\n    }\n\n    this.setHour(date, defaultTime[0] || 0);\n    this.setMinute(date, defaultTime[1] || 0);\n    this.setSecond(date, defaultTime[2] || 0);\n  }\n\n}\n\nif (false) {\n  /**\r\n   * Gets the hour component of the given date.\r\n   * @abstract\r\n   * @param {?} date The date to extract the month from.\r\n   * @return {?} The hour component.\r\n   */\n  NgxMatDateAdapter.prototype.getHour = function (date) {};\n  /**\r\n   * Gets the minute component of the given date.\r\n   * @abstract\r\n   * @param {?} date The date to extract the month from.\r\n   * @return {?} The minute component.\r\n   */\n\n\n  NgxMatDateAdapter.prototype.getMinute = function (date) {};\n  /**\r\n   * Gets the second component of the given date.\r\n   * @abstract\r\n   * @param {?} date The date to extract the month from.\r\n   * @return {?} The second component.\r\n   */\n\n\n  NgxMatDateAdapter.prototype.getSecond = function (date) {};\n  /**\r\n   * Set the hour component of the given date.\r\n   * @abstract\r\n   * @param {?} date The date to extract the month from.\r\n   * @param {?} value The value to set.\r\n   * @return {?}\r\n   */\n\n\n  NgxMatDateAdapter.prototype.setHour = function (date, value) {};\n  /**\r\n   * Set the second component of the given date.\r\n   * @abstract\r\n   * @param {?} date The date to extract the month from.\r\n   * @param {?} value The value to set.\r\n   * @return {?}\r\n   */\n\n\n  NgxMatDateAdapter.prototype.setMinute = function (date, value) {};\n  /**\r\n   * Set the second component of the given date.\r\n   * @abstract\r\n   * @param {?} date The date to extract the month from.\r\n   * @param {?} value The value to set.\r\n   * @return {?}\r\n   */\n\n\n  NgxMatDateAdapter.prototype.setSecond = function (date, value) {};\n}\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: lib/core/date-formats.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/** @type {?} */\n\n\nconst NGX_MAT_DATE_FORMATS = new InjectionToken('ngx-mat-date-formats');\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: lib/calendar-body.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * An internal class that represents the data corresponding to a single calendar cell.\r\n * \\@docs-private\r\n * @template D\r\n */\n\nclass NgxMatCalendarCell {\n  /**\r\n   * @param {?} value\r\n   * @param {?} displayValue\r\n   * @param {?} ariaLabel\r\n   * @param {?} enabled\r\n   * @param {?=} cssClasses\r\n   * @param {?=} compareValue\r\n   * @param {?=} rawValue\r\n   */\n  constructor(value, displayValue, ariaLabel, enabled, cssClasses = {}, compareValue = value, rawValue) {\n    this.value = value;\n    this.displayValue = displayValue;\n    this.ariaLabel = ariaLabel;\n    this.enabled = enabled;\n    this.cssClasses = cssClasses;\n    this.compareValue = compareValue;\n    this.rawValue = rawValue;\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  NgxMatCalendarCell.prototype.value;\n  /** @type {?} */\n\n  NgxMatCalendarCell.prototype.displayValue;\n  /** @type {?} */\n\n  NgxMatCalendarCell.prototype.ariaLabel;\n  /** @type {?} */\n\n  NgxMatCalendarCell.prototype.enabled;\n  /** @type {?} */\n\n  NgxMatCalendarCell.prototype.cssClasses;\n  /** @type {?} */\n\n  NgxMatCalendarCell.prototype.compareValue;\n  /** @type {?} */\n\n  NgxMatCalendarCell.prototype.rawValue;\n}\n/**\r\n * Event emitted when a date inside the calendar is triggered as a result of a user action.\r\n * @record\r\n * @template D\r\n */\n\n\nfunction NgxMatCalendarUserEvent() {}\n\nif (false) {\n  /** @type {?} */\n  NgxMatCalendarUserEvent.prototype.value;\n  /** @type {?} */\n\n  NgxMatCalendarUserEvent.prototype.event;\n}\n/**\r\n * An internal component used to display calendar data in a table.\r\n * \\@docs-private\r\n */\n\n\nlet NgxMatCalendarBody = /*#__PURE__*/(() => {\n  class NgxMatCalendarBody {\n    /**\r\n     * @param {?} _elementRef\r\n     * @param {?} _ngZone\r\n     */\n    constructor(_elementRef, _ngZone) {\n      this._elementRef = _elementRef;\n      this._ngZone = _ngZone;\n      /**\r\n       * The number of columns in the table.\r\n       */\n\n      this.numCols = 7;\n      /**\r\n       * The cell number of the active cell in the table.\r\n       */\n\n      this.activeCell = 0;\n      /**\r\n       * Whether a range is being selected.\r\n       */\n\n      this.isRange = false;\n      /**\r\n       * The aspect ratio (width / height) to use for the cells in the table. This aspect ratio will be\r\n       * maintained even as the table resizes.\r\n       */\n\n      this.cellAspectRatio = 1;\n      /**\r\n       * Start of the preview range.\r\n       */\n\n      this.previewStart = null;\n      /**\r\n       * End of the preview range.\r\n       */\n\n      this.previewEnd = null;\n      /**\r\n       * Emits when a new value is selected.\r\n       */\n\n      this.selectedValueChange = new EventEmitter();\n      /**\r\n       * Emits when the preview has changed as a result of a user action.\r\n       */\n\n      this.previewChange = new EventEmitter();\n      /**\r\n       * Event handler for when the user enters an element\r\n       * inside the calendar body (e.g. by hovering in or focus).\r\n       */\n\n      this._enterHandler =\n      /**\r\n      * @param {?} event\r\n      * @return {?}\r\n      */\n      event => {\n        if (this._skipNextFocus && event.type === 'focus') {\n          this._skipNextFocus = false;\n          return;\n        } // We only need to hit the zone when we're selecting a range.\n\n\n        if (event.target && this.isRange) {\n          /** @type {?} */\n          const cell = this._getCellFromElement(\n          /** @type {?} */\n          event.target);\n\n          if (cell) {\n            this._ngZone.run(\n            /**\r\n            * @return {?}\r\n            */\n            () => this.previewChange.emit({\n              value: cell.enabled ? cell : null,\n              event\n            }));\n          }\n        }\n      };\n      /**\r\n       * Event handler for when the user's pointer leaves an element\r\n       * inside the calendar body (e.g. by hovering out or blurring).\r\n       */\n\n\n      this._leaveHandler =\n      /**\r\n      * @param {?} event\r\n      * @return {?}\r\n      */\n      event => {\n        // We only need to hit the zone when we're selecting a range.\n        if (this.previewEnd !== null && this.isRange) {\n          // Only reset the preview end value when leaving cells. This looks better, because\n          // we have a gap between the cells and the rows and we don't want to remove the\n          // range just for it to show up again when the user moves a few pixels to the side.\n          if (event.target && isTableCell(\n          /** @type {?} */\n          event.target)) {\n            this._ngZone.run(\n            /**\r\n            * @return {?}\r\n            */\n            () => this.previewChange.emit({\n              value: null,\n              event\n            }));\n          }\n        }\n      };\n\n      _ngZone.runOutsideAngular(\n      /**\r\n      * @return {?}\r\n      */\n      () => {\n        /** @type {?} */\n        const element = _elementRef.nativeElement;\n        element.addEventListener('mouseenter', this._enterHandler, true);\n        element.addEventListener('focus', this._enterHandler, true);\n        element.addEventListener('mouseleave', this._leaveHandler, true);\n        element.addEventListener('blur', this._leaveHandler, true);\n      });\n    }\n    /**\r\n     * Called when a cell is clicked.\r\n     * @param {?} cell\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\n\n\n    _cellClicked(cell, event) {\n      if (cell.enabled) {\n        this.selectedValueChange.emit({\n          value: cell.value,\n          event\n        });\n      }\n    }\n    /**\r\n     * Returns whether a cell should be marked as selected.\r\n     * @param {?} cell\r\n     * @return {?}\r\n     */\n\n\n    _isSelected(cell) {\n      return this.startValue === cell.compareValue || this.endValue === cell.compareValue;\n    }\n    /**\r\n     * @param {?} changes\r\n     * @return {?}\r\n     */\n\n\n    ngOnChanges(changes) {\n      /** @type {?} */\n      const columnChanges = changes['numCols'];\n      const {\n        rows,\n        numCols\n      } = this;\n\n      if (changes['rows'] || columnChanges) {\n        this._firstRowOffset = rows && rows.length && rows[0].length ? numCols - rows[0].length : 0;\n      }\n\n      if (changes['cellAspectRatio'] || columnChanges || !this._cellPadding) {\n        this._cellPadding = `${50 * this.cellAspectRatio / numCols}%`;\n      }\n\n      if (columnChanges || !this._cellWidth) {\n        this._cellWidth = `${100 / numCols}%`;\n      }\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    ngOnDestroy() {\n      /** @type {?} */\n      const element = this._elementRef.nativeElement;\n      element.removeEventListener('mouseenter', this._enterHandler, true);\n      element.removeEventListener('focus', this._enterHandler, true);\n      element.removeEventListener('mouseleave', this._leaveHandler, true);\n      element.removeEventListener('blur', this._leaveHandler, true);\n    }\n    /**\r\n     * Returns whether a cell is active.\r\n     * @param {?} rowIndex\r\n     * @param {?} colIndex\r\n     * @return {?}\r\n     */\n\n\n    _isActiveCell(rowIndex, colIndex) {\n      /** @type {?} */\n      let cellNumber = rowIndex * this.numCols + colIndex; // Account for the fact that the first row may not have as many cells.\n\n      if (rowIndex) {\n        cellNumber -= this._firstRowOffset;\n      }\n\n      return cellNumber == this.activeCell;\n    }\n    /**\r\n     * Focuses the active cell after the microtask queue is empty.\r\n     * @param {?=} movePreview\r\n     * @return {?}\r\n     */\n\n\n    _focusActiveCell(movePreview = true) {\n      this._ngZone.runOutsideAngular(\n      /**\r\n      * @return {?}\r\n      */\n      () => {\n        this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(\n        /**\r\n        * @return {?}\r\n        */\n        () => {\n          /** @type {?} */\n          const activeCell = this._elementRef.nativeElement.querySelector('.ngx-mat-calendar-body-active');\n\n          if (activeCell) {\n            if (!movePreview) {\n              this._skipNextFocus = true;\n            }\n\n            activeCell.focus();\n          }\n        });\n      });\n    }\n    /**\r\n     * Gets whether a value is the start of the main range.\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    _isRangeStart(value) {\n      return isStart(value, this.startValue, this.endValue);\n    }\n    /**\r\n     * Gets whether a value is the end of the main range.\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    _isRangeEnd(value) {\n      return isEnd(value, this.startValue, this.endValue);\n    }\n    /**\r\n     * Gets whether a value is within the currently-selected range.\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    _isInRange(value) {\n      return isInRange(value, this.startValue, this.endValue, this.isRange);\n    }\n    /**\r\n     * Gets whether a value is the start of the comparison range.\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    _isComparisonStart(value) {\n      return isStart(value, this.comparisonStart, this.comparisonEnd);\n    }\n    /**\r\n     * Whether the cell is a start bridge cell between the main and comparison ranges.\r\n     * @param {?} value\r\n     * @param {?} rowIndex\r\n     * @param {?} colIndex\r\n     * @return {?}\r\n     */\n\n\n    _isComparisonBridgeStart(value, rowIndex, colIndex) {\n      if (!this._isComparisonStart(value) || this._isRangeStart(value) || !this._isInRange(value)) {\n        return false;\n      }\n      /** @type {?} */\n\n\n      let previousCell = this.rows[rowIndex][colIndex - 1];\n\n      if (!previousCell) {\n        /** @type {?} */\n        const previousRow = this.rows[rowIndex - 1];\n        previousCell = previousRow && previousRow[previousRow.length - 1];\n      }\n\n      return previousCell && !this._isRangeEnd(previousCell.compareValue);\n    }\n    /**\r\n     * Whether the cell is an end bridge cell between the main and comparison ranges.\r\n     * @param {?} value\r\n     * @param {?} rowIndex\r\n     * @param {?} colIndex\r\n     * @return {?}\r\n     */\n\n\n    _isComparisonBridgeEnd(value, rowIndex, colIndex) {\n      if (!this._isComparisonEnd(value) || this._isRangeEnd(value) || !this._isInRange(value)) {\n        return false;\n      }\n      /** @type {?} */\n\n\n      let nextCell = this.rows[rowIndex][colIndex + 1];\n\n      if (!nextCell) {\n        /** @type {?} */\n        const nextRow = this.rows[rowIndex + 1];\n        nextCell = nextRow && nextRow[0];\n      }\n\n      return nextCell && !this._isRangeStart(nextCell.compareValue);\n    }\n    /**\r\n     * Gets whether a value is the end of the comparison range.\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    _isComparisonEnd(value) {\n      return isEnd(value, this.comparisonStart, this.comparisonEnd);\n    }\n    /**\r\n     * Gets whether a value is within the current comparison range.\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    _isInComparisonRange(value) {\n      return isInRange(value, this.comparisonStart, this.comparisonEnd, this.isRange);\n    }\n    /**\r\n     * Gets whether a value is the start of the preview range.\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    _isPreviewStart(value) {\n      return isStart(value, this.previewStart, this.previewEnd);\n    }\n    /**\r\n     * Gets whether a value is the end of the preview range.\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    _isPreviewEnd(value) {\n      return isEnd(value, this.previewStart, this.previewEnd);\n    }\n    /**\r\n     * Gets whether a value is inside the preview range.\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    _isInPreview(value) {\n      return isInRange(value, this.previewStart, this.previewEnd, this.isRange);\n    }\n    /**\r\n     * Finds the NgxMatCalendarCell that corresponds to a DOM node.\r\n     * @private\r\n     * @param {?} element\r\n     * @return {?}\r\n     */\n\n\n    _getCellFromElement(element) {\n      /** @type {?} */\n      let cell;\n\n      if (isTableCell(element)) {\n        cell = element;\n      } else if (isTableCell(\n      /** @type {?} */\n      element.parentNode)) {\n        cell =\n        /** @type {?} */\n        element.parentNode;\n      }\n\n      if (cell) {\n        /** @type {?} */\n        const row = cell.getAttribute('data-ngx-mat-row');\n        /** @type {?} */\n\n        const col = cell.getAttribute('data-ngx-mat-col');\n\n        if (row && col) {\n          return this.rows[parseInt(row)][parseInt(col)];\n        }\n      }\n\n      return null;\n    }\n\n  }\n\n  NgxMatCalendarBody.ɵfac = function NgxMatCalendarBody_Factory(t) {\n    return new (t || NgxMatCalendarBody)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  NgxMatCalendarBody.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: NgxMatCalendarBody,\n    selectors: [[\"\", \"ngx-mat-calendar-body\", \"\"]],\n    hostAttrs: [\"role\", \"grid\", \"aria-readonly\", \"true\", 1, \"ngx-mat-calendar-body\"],\n    inputs: {\n      numCols: \"numCols\",\n      activeCell: \"activeCell\",\n      isRange: \"isRange\",\n      cellAspectRatio: \"cellAspectRatio\",\n      previewStart: \"previewStart\",\n      previewEnd: \"previewEnd\",\n      label: \"label\",\n      rows: \"rows\",\n      todayValue: \"todayValue\",\n      startValue: \"startValue\",\n      endValue: \"endValue\",\n      labelMinRequiredCells: \"labelMinRequiredCells\",\n      comparisonStart: \"comparisonStart\",\n      comparisonEnd: \"comparisonEnd\"\n    },\n    outputs: {\n      selectedValueChange: \"selectedValueChange\",\n      previewChange: \"previewChange\"\n    },\n    exportAs: [\"NgxMatCalendarBody\"],\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    attrs: _c0,\n    decls: 2,\n    vars: 2,\n    consts: [[\"aria-hidden\", \"true\", 4, \"ngIf\"], [\"role\", \"row\", 4, \"ngFor\", \"ngForOf\"], [\"aria-hidden\", \"true\"], [1, \"mat-calendar-body-label\"], [\"role\", \"row\"], [\"aria-hidden\", \"true\", \"class\", \"mat-calendar-body-label\", 3, \"paddingTop\", \"paddingBottom\", 4, \"ngIf\"], [\"role\", \"gridcell\", \"class\", \"mat-calendar-body-cell\", 3, \"ngClass\", \"tabindex\", \"mat-calendar-body-disabled\", \"mat-calendar-body-active\", \"mat-calendar-body-range-start\", \"mat-calendar-body-range-end\", \"mat-calendar-body-in-range\", \"mat-calendar-body-comparison-bridge-start\", \"mat-calendar-body-comparison-bridge-end\", \"mat-calendar-body-comparison-start\", \"mat-calendar-body-comparison-end\", \"mat-calendar-body-in-comparison-range\", \"mat-calendar-body-preview-start\", \"mat-calendar-body-preview-end\", \"mat-calendar-body-in-preview\", \"width\", \"paddingTop\", \"paddingBottom\", \"click\", 4, \"ngFor\", \"ngForOf\"], [\"aria-hidden\", \"true\", 1, \"mat-calendar-body-label\"], [\"role\", \"gridcell\", 1, \"mat-calendar-body-cell\", 3, \"ngClass\", \"tabindex\", \"click\"], [1, \"mat-calendar-body-cell-content\", \"mat-focus-indicator\"], [1, \"mat-calendar-body-cell-preview\"]],\n    template: function NgxMatCalendarBody_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, NgxMatCalendarBody_tr_0_Template, 3, 6, \"tr\", 0);\n        ɵngcc0.ɵɵtemplate(1, NgxMatCalendarBody_tr_1_Template, 3, 2, \"tr\", 1);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx._firstRowOffset < ctx.labelMinRequiredCells);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.rows);\n      }\n    },\n    directives: [ɵngcc1.NgIf, ɵngcc1.NgForOf, ɵngcc1.NgClass],\n    styles: [\".mat-calendar-body{min-width:224px}.mat-calendar-body-label{height:0;line-height:0;padding-left:4.7142857143%;padding-right:4.7142857143%;text-align:left}.mat-calendar-body-cell{cursor:pointer;height:0;line-height:0;outline:none;position:relative;text-align:center}.mat-calendar-body-cell-preview,.mat-calendar-body-cell:after,.mat-calendar-body-cell:before{box-sizing:border-box;content:\\\"\\\";height:90%;left:0;position:absolute;top:5%;width:100%;z-index:0}.mat-calendar-body-comparison-start:after,.mat-calendar-body-comparison-start:not(.mat-calendar-body-comparison-bridge-start):before,.mat-calendar-body-preview-start .mat-calendar-body-cell-preview,.mat-calendar-body-range-start:after,.mat-calendar-body-range-start:not(.mat-calendar-body-in-comparison-range):before{border-bottom-left-radius:999px;border-top-left-radius:999px;left:5%;width:95%}[dir=rtl] .mat-calendar-body-comparison-start:after,[dir=rtl] .mat-calendar-body-comparison-start:not(.mat-calendar-body-comparison-bridge-start):before,[dir=rtl] .mat-calendar-body-preview-start .mat-calendar-body-cell-preview,[dir=rtl] .mat-calendar-body-range-start:after,[dir=rtl] .mat-calendar-body-range-start:not(.mat-calendar-body-in-comparison-range):before{border-bottom-right-radius:999px;border-radius:0;border-top-right-radius:999px;left:0}.mat-calendar-body-comparison-end:after,.mat-calendar-body-comparison-end:not(.mat-calendar-body-comparison-bridge-end):before,.mat-calendar-body-preview-end .mat-calendar-body-cell-preview,.mat-calendar-body-range-end:after,.mat-calendar-body-range-end:not(.mat-calendar-body-in-comparison-range):before{border-bottom-right-radius:999px;border-top-right-radius:999px;width:95%}[dir=rtl] .mat-calendar-body-comparison-end:after,[dir=rtl] .mat-calendar-body-comparison-end:not(.mat-calendar-body-comparison-bridge-end):before,[dir=rtl] .mat-calendar-body-preview-end .mat-calendar-body-cell-preview,[dir=rtl] .mat-calendar-body-range-end:after,[dir=rtl] .mat-calendar-body-range-end:not(.mat-calendar-body-in-comparison-range):before{border-bottom-left-radius:999px;border-radius:0;border-top-left-radius:999px;left:5%}[dir=rtl] .mat-calendar-body-comparison-bridge-end.mat-calendar-body-range-start:after,[dir=rtl] .mat-calendar-body-comparison-bridge-start.mat-calendar-body-range-end:after{border-bottom-right-radius:999px;border-top-right-radius:999px;width:95%}.mat-calendar-body-comparison-end.mat-calendar-body-range-start:after,.mat-calendar-body-comparison-start.mat-calendar-body-range-end:after,[dir=rtl] .mat-calendar-body-comparison-end.mat-calendar-body-range-start:after,[dir=rtl] .mat-calendar-body-comparison-start.mat-calendar-body-range-end:after{width:90%}.mat-calendar-body-in-preview .mat-calendar-body-cell-preview{border-bottom:1px dashed;border-top:1px dashed}.mat-calendar-body-preview-start .mat-calendar-body-cell-preview{border-left:1px dashed}[dir=rtl] .mat-calendar-body-preview-start .mat-calendar-body-cell-preview{border-left:0;border-right:1px dashed}.mat-calendar-body-preview-end .mat-calendar-body-cell-preview{border-right:1px dashed}[dir=rtl] .mat-calendar-body-preview-end .mat-calendar-body-cell-preview{border-left:1px dashed;border-right:0}.mat-calendar-body-disabled{cursor:default}.mat-calendar-body-cell-content{align-items:center;border-radius:999px;border-style:solid;border-width:1px;box-sizing:border-box;display:flex;height:90%;justify-content:center;left:5%;line-height:1;top:5%;width:90%;z-index:1}.mat-calendar-body-cell-content.mat-focus-indicator{position:absolute}.cdk-high-contrast-active .mat-calendar-body-cell-content{border:none}.cdk-high-contrast-active .mat-calendar-body-selected,.cdk-high-contrast-active .mat-datepicker-popup:not(:empty){outline:1px solid}.cdk-high-contrast-active .mat-calendar-body-today{outline:1px dotted}.cdk-high-contrast-active .cdk-keyboard-focused .mat-calendar-body-active>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected),.cdk-high-contrast-active .cdk-program-focused .mat-calendar-body-active>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected){outline:2px dotted}[dir=rtl] .mat-calendar-body-label{text-align:right}@media (hover:none){.mat-calendar-body-cell:not(.mat-calendar-body-disabled):hover>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected){background-color:transparent}}\"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return NgxMatCalendarBody;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\r\n   * Used to skip the next focus event when rendering the preview range.\r\n   * We need a flag like this, because some browsers fire focus events asynchronously.\r\n   * @type {?}\r\n   * @private\r\n   */\n  NgxMatCalendarBody.prototype._skipNextFocus;\n  /**\r\n   * The label for the table. (e.g. \"Jan 2017\").\r\n   * @type {?}\r\n   */\n\n  NgxMatCalendarBody.prototype.label;\n  /**\r\n   * The cells to display in the table.\r\n   * @type {?}\r\n   */\n\n  NgxMatCalendarBody.prototype.rows;\n  /**\r\n   * The value in the table that corresponds to today.\r\n   * @type {?}\r\n   */\n\n  NgxMatCalendarBody.prototype.todayValue;\n  /**\r\n   * Start value of the selected date range.\r\n   * @type {?}\r\n   */\n\n  NgxMatCalendarBody.prototype.startValue;\n  /**\r\n   * End value of the selected date range.\r\n   * @type {?}\r\n   */\n\n  NgxMatCalendarBody.prototype.endValue;\n  /**\r\n   * The minimum number of free cells needed to fit the label in the first row.\r\n   * @type {?}\r\n   */\n\n  NgxMatCalendarBody.prototype.labelMinRequiredCells;\n  /**\r\n   * The number of columns in the table.\r\n   * @type {?}\r\n   */\n\n  NgxMatCalendarBody.prototype.numCols;\n  /**\r\n   * The cell number of the active cell in the table.\r\n   * @type {?}\r\n   */\n\n  NgxMatCalendarBody.prototype.activeCell;\n  /**\r\n   * Whether a range is being selected.\r\n   * @type {?}\r\n   */\n\n  NgxMatCalendarBody.prototype.isRange;\n  /**\r\n   * The aspect ratio (width / height) to use for the cells in the table. This aspect ratio will be\r\n   * maintained even as the table resizes.\r\n   * @type {?}\r\n   */\n\n  NgxMatCalendarBody.prototype.cellAspectRatio;\n  /**\r\n   * Start of the comparison range.\r\n   * @type {?}\r\n   */\n\n  NgxMatCalendarBody.prototype.comparisonStart;\n  /**\r\n   * End of the comparison range.\r\n   * @type {?}\r\n   */\n\n  NgxMatCalendarBody.prototype.comparisonEnd;\n  /**\r\n   * Start of the preview range.\r\n   * @type {?}\r\n   */\n\n  NgxMatCalendarBody.prototype.previewStart;\n  /**\r\n   * End of the preview range.\r\n   * @type {?}\r\n   */\n\n  NgxMatCalendarBody.prototype.previewEnd;\n  /**\r\n   * Emits when a new value is selected.\r\n   * @type {?}\r\n   */\n\n  NgxMatCalendarBody.prototype.selectedValueChange;\n  /**\r\n   * Emits when the preview has changed as a result of a user action.\r\n   * @type {?}\r\n   */\n\n  NgxMatCalendarBody.prototype.previewChange;\n  /**\r\n   * The number of blank cells to put at the beginning for the first row.\r\n   * @type {?}\r\n   */\n\n  NgxMatCalendarBody.prototype._firstRowOffset;\n  /**\r\n   * Padding for the individual date cells.\r\n   * @type {?}\r\n   */\n\n  NgxMatCalendarBody.prototype._cellPadding;\n  /**\r\n   * Width of an individual cell.\r\n   * @type {?}\r\n   */\n\n  NgxMatCalendarBody.prototype._cellWidth;\n  /**\r\n   * Event handler for when the user enters an element\r\n   * inside the calendar body (e.g. by hovering in or focus).\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatCalendarBody.prototype._enterHandler;\n  /**\r\n   * Event handler for when the user's pointer leaves an element\r\n   * inside the calendar body (e.g. by hovering out or blurring).\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatCalendarBody.prototype._leaveHandler;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatCalendarBody.prototype._elementRef;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatCalendarBody.prototype._ngZone;\n}\n/**\r\n * Checks whether a node is a table cell element.\r\n * @param {?} node\r\n * @return {?}\r\n */\n\n\nfunction isTableCell(node) {\n  return node.nodeName === 'TD';\n}\n/**\r\n * Checks whether a value is the start of a range.\r\n * @param {?} value\r\n * @param {?} start\r\n * @param {?} end\r\n * @return {?}\r\n */\n\n\nfunction isStart(value, start, end) {\n  return end !== null && start !== end && value < end && value === start;\n}\n/**\r\n * Checks whether a value is the end of a range.\r\n * @param {?} value\r\n * @param {?} start\r\n * @param {?} end\r\n * @return {?}\r\n */\n\n\nfunction isEnd(value, start, end) {\n  return start !== null && start !== end && value >= start && value === end;\n}\n/**\r\n * Checks whether a value is inside of a range.\r\n * @param {?} value\r\n * @param {?} start\r\n * @param {?} end\r\n * @param {?} rangeEnabled\r\n * @return {?}\r\n */\n\n\nfunction isInRange(value, start, end, rangeEnabled) {\n  return rangeEnabled && start !== null && end !== null && start !== end && value >= start && value <= end;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: lib/date-range-selection-strategy.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * Injection token used to customize the date range selection behavior.\r\n * @type {?}\r\n */\n\n\nconst NGX_MAT_DATE_RANGE_SELECTION_STRATEGY = new InjectionToken('NGX_MAT_DATE_RANGE_SELECTION_STRATEGY');\n/**\r\n * Object that can be provided in order to customize the date range selection behavior.\r\n * @record\r\n * @template D\r\n */\n\nfunction NgxMatDateRangeSelectionStrategy() {}\n\nif (false) {\n  /**\r\n   * Called when the user has finished selecting a value.\r\n   * @param {?} date Date that was selected. Will be null if the user cleared the selection.\r\n   * @param {?} currentRange Range that is currently show in the calendar.\r\n   * @param {?} event DOM event that triggered the selection. Currently only corresponds to a `click`\r\n   *    event, but it may get expanded in the future.\r\n   * @return {?}\r\n   */\n  NgxMatDateRangeSelectionStrategy.prototype.selectionFinished = function (date, currentRange, event) {};\n  /**\r\n   * Called when the user has activated a new date (e.g. by hovering over\r\n   * it or moving focus) and the calendar tries to display a date range.\r\n   *\r\n   * @param {?} activeDate Date that the user has activated. Will be null if the user moved\r\n   *    focus to an element that's no a calendar cell.\r\n   * @param {?} currentRange Range that is currently shown in the calendar.\r\n   * @param {?} event DOM event that caused the preview to be changed. Will be either a\r\n   *    `mouseenter`/`mouseleave` or `focus`/`blur` depending on how the user is navigating.\r\n   * @return {?}\r\n   */\n\n\n  NgxMatDateRangeSelectionStrategy.prototype.createPreview = function (activeDate, currentRange, event) {};\n}\n/**\r\n * Provides the default date range selection behavior.\r\n * @template D\r\n */\n\n\nlet DefaultNgxMatCalendarRangeStrategy = /*#__PURE__*/(() => {\n  class DefaultNgxMatCalendarRangeStrategy {\n    /**\r\n     * @param {?} _dateAdapter\r\n     */\n    constructor(_dateAdapter) {\n      this._dateAdapter = _dateAdapter;\n    }\n    /**\r\n     * @param {?} date\r\n     * @param {?} currentRange\r\n     * @return {?}\r\n     */\n\n\n    selectionFinished(date, currentRange) {\n      let {\n        start,\n        end\n      } = currentRange;\n\n      if (start == null) {\n        start = date;\n      } else if (end == null && date && this._dateAdapter.compareDate(date, start) >= 0) {\n        end = date;\n      } else {\n        start = date;\n        end = null;\n      }\n\n      return new DateRange(start, end);\n    }\n    /**\r\n     * @param {?} activeDate\r\n     * @param {?} currentRange\r\n     * @return {?}\r\n     */\n\n\n    createPreview(activeDate, currentRange) {\n      /** @type {?} */\n      let start = null;\n      /** @type {?} */\n\n      let end = null;\n\n      if (currentRange.start && !currentRange.end && activeDate) {\n        start = currentRange.start;\n        end = activeDate;\n      }\n\n      return new DateRange(start, end);\n    }\n\n  }\n\n  DefaultNgxMatCalendarRangeStrategy.ɵfac = function DefaultNgxMatCalendarRangeStrategy_Factory(t) {\n    return new (t || DefaultNgxMatCalendarRangeStrategy)(ɵngcc0.ɵɵinject(NgxMatDateAdapter));\n  };\n\n  DefaultNgxMatCalendarRangeStrategy.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: DefaultNgxMatCalendarRangeStrategy,\n    factory: DefaultNgxMatCalendarRangeStrategy.ɵfac\n  });\n  /** @nocollapse */\n\n  return DefaultNgxMatCalendarRangeStrategy;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n  DefaultNgxMatCalendarRangeStrategy.prototype._dateAdapter;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: lib/utils/date-utils.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/** @type {?} */\n\n\nconst LIMIT_TIMES = {\n  minHour: 0,\n  maxHour: 24,\n  minMinute: 0,\n  maxMinute: 60,\n  minSecond: 0,\n  maxSecond: 60,\n  meridian: 12\n};\n/** @type {?} */\n\nconst MERIDIANS = {\n  AM: 'AM',\n  PM: 'PM'\n};\n/** @type {?} */\n\nconst DEFAULT_STEP = 1;\n/** @type {?} */\n\nconst NUMERIC_REGEX = /[^0-9]/g;\n/** @type {?} */\n\nconst PATTERN_INPUT_HOUR = /^(2[0-3]|[0-1][0-9]|[0-9])$/;\n/** @type {?} */\n\nconst PATTERN_INPUT_MINUTE = /^([0-5][0-9]|[0-9])$/;\n/** @type {?} */\n\nconst PATTERN_INPUT_SECOND = /^([0-5][0-9]|[0-9])$/;\n/**\r\n * @param {?} val\r\n * @return {?}\r\n */\n\nfunction formatTwoDigitTimeValue(val) {\n  /** @type {?} */\n  const txt = val.toString();\n  return txt.length > 1 ? txt : `0${txt}`;\n}\n/**\r\n * @param {?} provider\r\n * @return {?}\r\n */\n\n\nfunction createMissingDateImplError(provider) {\n  return Error(`NgxMatDatepicker: No provider found for ${provider}. You must import one of the following ` + `modules at your application root: NgxMatNativeDateModule, NgxMatMomentModule, or provide a ` + `custom implementation.`);\n}\n/**\r\n * Formats a range of years.\r\n * @param {?} start\r\n * @param {?} end\r\n * @return {?}\r\n */\n\n\nfunction formatYearRange(start, end) {\n  return `${start} \\u2013 ${end}`;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: lib/month-view.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/** @type {?} */\n\n\nconst DAYS_PER_WEEK = 7;\n/**\r\n * An internal component used to display a single month in the datepicker.\r\n * \\@docs-private\r\n * @template D\r\n */\n\nlet NgxMatMonthView = /*#__PURE__*/(() => {\n  class NgxMatMonthView {\n    /**\r\n     * @param {?} _changeDetectorRef\r\n     * @param {?} _dateFormats\r\n     * @param {?} _dateAdapter\r\n     * @param {?=} _dir\r\n     * @param {?=} _rangeStrategy\r\n     */\n    constructor(_changeDetectorRef, _dateFormats, _dateAdapter, _dir, _rangeStrategy) {\n      this._changeDetectorRef = _changeDetectorRef;\n      this._dateFormats = _dateFormats;\n      this._dateAdapter = _dateAdapter;\n      this._dir = _dir;\n      this._rangeStrategy = _rangeStrategy;\n      this._rerenderSubscription = Subscription.EMPTY;\n      /**\r\n       * Emits when a new date is selected.\r\n       */\n\n      this.selectedChange = new EventEmitter();\n      /**\r\n       * Emits when any date is selected.\r\n       */\n\n      this._userSelection = new EventEmitter();\n      /**\r\n       * Emits when any date is activated.\r\n       */\n\n      this.activeDateChange = new EventEmitter();\n\n      if (!this._dateAdapter) {\n        throw createMissingDateImplError('NgxMatDateAdapter');\n      }\n\n      if (!this._dateFormats) {\n        throw createMissingDateImplError('NGX_MAT_DATE_FORMATS');\n      }\n\n      this._activeDate = this._dateAdapter.today();\n    }\n    /**\r\n     * The date to display in this month view (everything other than the month and year is ignored).\r\n     * @return {?}\r\n     */\n\n\n    get activeDate() {\n      return this._activeDate;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set activeDate(value) {\n      /** @type {?} */\n      const oldActiveDate = this._activeDate;\n      /** @type {?} */\n\n      const validDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();\n\n      this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);\n\n      if (!this._hasSameMonthAndYear(oldActiveDate, this._activeDate)) {\n        this._init();\n      }\n    }\n    /**\r\n     * The currently selected date.\r\n     * @return {?}\r\n     */\n\n\n    get selected() {\n      return this._selected;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set selected(value) {\n      if (value instanceof DateRange) {\n        this._selected = value;\n      } else {\n        this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n      }\n\n      this._setRanges(this._selected);\n    }\n    /**\r\n     * The minimum selectable date.\r\n     * @return {?}\r\n     */\n\n\n    get minDate() {\n      return this._minDate;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set minDate(value) {\n      this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n    /**\r\n     * The maximum selectable date.\r\n     * @return {?}\r\n     */\n\n\n    get maxDate() {\n      return this._maxDate;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set maxDate(value) {\n      this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    ngAfterContentInit() {\n      this._rerenderSubscription = this._dateAdapter.localeChanges.pipe(startWith(null)).subscribe(\n      /**\r\n      * @return {?}\r\n      */\n      () => this._init());\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    ngOnDestroy() {\n      this._rerenderSubscription.unsubscribe();\n    }\n    /**\r\n     * Handles when a new date is selected.\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\n\n\n    _dateSelected(event) {\n      /** @type {?} */\n      const date = event.value;\n      /** @type {?} */\n\n      const selectedYear = this._dateAdapter.getYear(this.activeDate);\n      /** @type {?} */\n\n\n      const selectedMonth = this._dateAdapter.getMonth(this.activeDate);\n      /** @type {?} */\n\n\n      const selectedDate = this._dateAdapter.createDate(selectedYear, selectedMonth, date);\n      /** @type {?} */\n\n\n      let rangeStartDate;\n      /** @type {?} */\n\n      let rangeEndDate;\n\n      if (this._selected instanceof DateRange) {\n        rangeStartDate = this._getDateInCurrentMonth(this._selected.start);\n        rangeEndDate = this._getDateInCurrentMonth(this._selected.end);\n      } else {\n        rangeStartDate = rangeEndDate = this._getDateInCurrentMonth(this._selected);\n      }\n\n      if (rangeStartDate !== date || rangeEndDate !== date) {\n        this.selectedChange.emit(selectedDate);\n      }\n\n      this._userSelection.emit({\n        value: selectedDate,\n        event: event.event\n      });\n    }\n    /**\r\n     * Handles keydown events on the calendar body when calendar is in month view.\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\n\n\n    _handleCalendarBodyKeydown(event) {\n      // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent\n      // disabled ones from being selected. This may not be ideal, we should look into whether\n      // navigation should skip over disabled dates, and if so, how to implement that efficiently.\n      // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent\n      // disabled ones from being selected. This may not be ideal, we should look into whether\n      // navigation should skip over disabled dates, and if so, how to implement that efficiently.\n\n      /** @type {?} */\n      const oldActiveDate = this._activeDate;\n      /** @type {?} */\n\n      const isRtl = this._isRtl();\n\n      switch (event.keyCode) {\n        case LEFT_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, isRtl ? 1 : -1);\n          break;\n\n        case RIGHT_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, isRtl ? -1 : 1);\n          break;\n\n        case UP_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, -7);\n          break;\n\n        case DOWN_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 7);\n          break;\n\n        case HOME:\n          this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 1 - this._dateAdapter.getDate(this._activeDate));\n          break;\n\n        case END:\n          this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, this._dateAdapter.getNumDaysInMonth(this._activeDate) - this._dateAdapter.getDate(this._activeDate));\n          break;\n\n        case PAGE_UP:\n          this.activeDate = event.altKey ? this._dateAdapter.addCalendarYears(this._activeDate, -1) : this._dateAdapter.addCalendarMonths(this._activeDate, -1);\n          break;\n\n        case PAGE_DOWN:\n          this.activeDate = event.altKey ? this._dateAdapter.addCalendarYears(this._activeDate, 1) : this._dateAdapter.addCalendarMonths(this._activeDate, 1);\n          break;\n\n        case ENTER:\n        case SPACE:\n          if (!this.dateFilter || this.dateFilter(this._activeDate)) {\n            this._dateSelected({\n              value: this._dateAdapter.getDate(this._activeDate),\n              event\n            }); // Prevent unexpected default actions such as form submission.\n\n\n            event.preventDefault();\n          }\n\n          return;\n\n        case ESCAPE:\n          // Abort the current range selection if the user presses escape mid-selection.\n          if (this._previewEnd != null) {\n            this._previewStart = this._previewEnd = null;\n            this.selectedChange.emit(null);\n\n            this._userSelection.emit({\n              value: null,\n              event\n            });\n\n            event.preventDefault();\n            event.stopPropagation(); // Prevents the overlay from closing.\n          }\n\n          return;\n\n        default:\n          // Don't prevent default or focus active cell on keys that we don't explicitly handle.\n          return;\n      }\n\n      if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {\n        this.activeDateChange.emit(this.activeDate);\n      }\n\n      this._focusActiveCell(); // Prevent unexpected default actions such as form submission.\n\n\n      event.preventDefault();\n    }\n    /**\r\n     * Initializes this month view.\r\n     * @return {?}\r\n     */\n\n\n    _init() {\n      this._setRanges(this.selected);\n\n      this._todayDate = this._getCellCompareValue(this._dateAdapter.today());\n      this._monthLabel = this._dateAdapter.getMonthNames('short')[this._dateAdapter.getMonth(this.activeDate)].toLocaleUpperCase();\n      /** @type {?} */\n\n      let firstOfMonth = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), 1);\n\n      this._firstWeekOffset = (DAYS_PER_WEEK + this._dateAdapter.getDayOfWeek(firstOfMonth) - this._dateAdapter.getFirstDayOfWeek()) % DAYS_PER_WEEK;\n\n      this._initWeekdays();\n\n      this._createWeekCells();\n\n      this._changeDetectorRef.markForCheck();\n    }\n    /**\r\n     * Focuses the active cell after the microtask queue is empty.\r\n     * @param {?=} movePreview\r\n     * @return {?}\r\n     */\n\n\n    _focusActiveCell(movePreview) {\n      this._matCalendarBody._focusActiveCell(movePreview);\n    }\n    /**\r\n     * Called when the user has activated a new cell and the preview needs to be updated.\r\n     * @param {?} __0\r\n     * @return {?}\r\n     */\n\n\n    _previewChanged({\n      event,\n      value: cell\n    }) {\n      if (this._rangeStrategy) {\n        // We can assume that this will be a range, because preview\n        // events aren't fired for single date selections.\n\n        /** @type {?} */\n        const value = cell ?\n        /** @type {?} */\n        cell.rawValue : null;\n        /** @type {?} */\n\n        const previewRange = this._rangeStrategy.createPreview(value,\n        /** @type {?} */\n        this.selected, event);\n\n        this._previewStart = this._getCellCompareValue(previewRange.start);\n        this._previewEnd = this._getCellCompareValue(previewRange.end); // Note that here we need to use `detectChanges`, rather than `markForCheck`, because\n        // the way `_focusActiveCell` is set up at the moment makes it fire at the wrong time\n        // when navigating one month back using the keyboard which will cause this handler\n        // to throw a \"changed after checked\" error when updating the preview state.\n\n        this._changeDetectorRef.detectChanges();\n      }\n    }\n    /**\r\n     * Initializes the weekdays.\r\n     * @private\r\n     * @return {?}\r\n     */\n\n\n    _initWeekdays() {\n      /** @type {?} */\n      const firstDayOfWeek = this._dateAdapter.getFirstDayOfWeek();\n      /** @type {?} */\n\n\n      const narrowWeekdays = this._dateAdapter.getDayOfWeekNames('narrow');\n      /** @type {?} */\n\n\n      const longWeekdays = this._dateAdapter.getDayOfWeekNames('long'); // Rotate the labels for days of the week based on the configured first day of the week.\n\n      /** @type {?} */\n\n\n      let weekdays = longWeekdays.map(\n      /**\r\n      * @param {?} long\r\n      * @param {?} i\r\n      * @return {?}\r\n      */\n      (long, i) => {\n        return {\n          long,\n          narrow: narrowWeekdays[i]\n        };\n      });\n      this._weekdays = weekdays.slice(firstDayOfWeek).concat(weekdays.slice(0, firstDayOfWeek));\n    }\n    /**\r\n     * Creates MatCalendarCells for the dates in this month.\r\n     * @private\r\n     * @return {?}\r\n     */\n\n\n    _createWeekCells() {\n      /** @type {?} */\n      const daysInMonth = this._dateAdapter.getNumDaysInMonth(this.activeDate);\n      /** @type {?} */\n\n\n      const dateNames = this._dateAdapter.getDateNames();\n\n      this._weeks = [[]];\n\n      for (let i = 0, cell = this._firstWeekOffset; i < daysInMonth; i++, cell++) {\n        if (cell == DAYS_PER_WEEK) {\n          this._weeks.push([]);\n\n          cell = 0;\n        }\n        /** @type {?} */\n\n\n        const date = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), i + 1);\n        /** @type {?} */\n\n\n        const enabled = this._shouldEnableDate(date);\n        /** @type {?} */\n\n\n        const ariaLabel = this._dateAdapter.format(date, this._dateFormats.display.dateA11yLabel);\n        /** @type {?} */\n\n\n        const cellClasses = this.dateClass ? this.dateClass(date) : undefined;\n\n        this._weeks[this._weeks.length - 1].push(new NgxMatCalendarCell(i + 1, dateNames[i], ariaLabel, enabled, cellClasses,\n        /** @type {?} */\n        this._getCellCompareValue(date), date));\n      }\n    }\n    /**\r\n     * Date filter for the month\r\n     * @private\r\n     * @param {?} date\r\n     * @return {?}\r\n     */\n\n\n    _shouldEnableDate(date) {\n      return !!date && (!this.minDate || this._dateAdapter.compareDate(date, this.minDate) >= 0) && (!this.maxDate || this._dateAdapter.compareDate(date, this.maxDate) <= 0) && (!this.dateFilter || this.dateFilter(date));\n    }\n    /**\r\n     * Gets the date in this month that the given Date falls on.\r\n     * Returns null if the given Date is in another month.\r\n     * @private\r\n     * @param {?} date\r\n     * @return {?}\r\n     */\n\n\n    _getDateInCurrentMonth(date) {\n      return date && this._hasSameMonthAndYear(date, this.activeDate) ? this._dateAdapter.getDate(date) : null;\n    }\n    /**\r\n     * Checks whether the 2 dates are non-null and fall within the same month of the same year.\r\n     * @private\r\n     * @param {?} d1\r\n     * @param {?} d2\r\n     * @return {?}\r\n     */\n\n\n    _hasSameMonthAndYear(d1, d2) {\n      return !!(d1 && d2 && this._dateAdapter.getMonth(d1) == this._dateAdapter.getMonth(d2) && this._dateAdapter.getYear(d1) == this._dateAdapter.getYear(d2));\n    }\n    /**\r\n     * Gets the value that will be used to one cell to another.\r\n     * @private\r\n     * @param {?} date\r\n     * @return {?}\r\n     */\n\n\n    _getCellCompareValue(date) {\n      if (date) {\n        // We use the time since the Unix epoch to compare dates in this view, rather than the\n        // cell values, because we need to support ranges that span across multiple months/years.\n\n        /** @type {?} */\n        const year = this._dateAdapter.getYear(date);\n        /** @type {?} */\n\n\n        const month = this._dateAdapter.getMonth(date);\n        /** @type {?} */\n\n\n        const day = this._dateAdapter.getDate(date);\n\n        return new Date(year, month, day).getTime();\n      }\n\n      return null;\n    }\n    /**\r\n     * @private\r\n     * @param {?} obj The object to check.\r\n     * @return {?} The given object if it is both a date instance and valid, otherwise null.\r\n     */\n\n\n    _getValidDateOrNull(obj) {\n      return this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj) ? obj : null;\n    }\n    /**\r\n     * Determines whether the user has the RTL layout direction.\r\n     * @private\r\n     * @return {?}\r\n     */\n\n\n    _isRtl() {\n      return this._dir && this._dir.value === 'rtl';\n    }\n    /**\r\n     * Sets the current range based on a model value.\r\n     * @private\r\n     * @param {?} selectedValue\r\n     * @return {?}\r\n     */\n\n\n    _setRanges(selectedValue) {\n      if (selectedValue instanceof DateRange) {\n        this._rangeStart = this._getCellCompareValue(selectedValue.start);\n        this._rangeEnd = this._getCellCompareValue(selectedValue.end);\n        this._isRange = true;\n      } else {\n        this._rangeStart = this._rangeEnd = this._getCellCompareValue(selectedValue);\n        this._isRange = false;\n      }\n\n      this._comparisonRangeStart = this._getCellCompareValue(this.comparisonStart);\n      this._comparisonRangeEnd = this._getCellCompareValue(this.comparisonEnd);\n    }\n\n  }\n\n  NgxMatMonthView.ɵfac = function NgxMatMonthView_Factory(t) {\n    return new (t || NgxMatMonthView)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(NGX_MAT_DATE_FORMATS, 8), ɵngcc0.ɵɵdirectiveInject(NgxMatDateAdapter, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Directionality, 8), ɵngcc0.ɵɵdirectiveInject(NGX_MAT_DATE_RANGE_SELECTION_STRATEGY, 8));\n  };\n\n  NgxMatMonthView.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: NgxMatMonthView,\n    selectors: [[\"ngx-mat-month-view\"]],\n    viewQuery: function NgxMatMonthView_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(NgxMatCalendarBody, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._matCalendarBody = _t.first);\n      }\n    },\n    inputs: {\n      activeDate: \"activeDate\",\n      selected: \"selected\",\n      minDate: \"minDate\",\n      maxDate: \"maxDate\",\n      dateFilter: \"dateFilter\",\n      dateClass: \"dateClass\",\n      comparisonStart: \"comparisonStart\",\n      comparisonEnd: \"comparisonEnd\"\n    },\n    outputs: {\n      selectedChange: \"selectedChange\",\n      _userSelection: \"_userSelection\",\n      activeDateChange: \"activeDateChange\"\n    },\n    exportAs: [\"ngxMatMonthView\"],\n    decls: 7,\n    vars: 13,\n    consts: [[\"role\", \"presentation\", 1, \"mat-calendar-table\"], [1, \"mat-calendar-table-header\"], [\"scope\", \"col\", 4, \"ngFor\", \"ngForOf\"], [\"colspan\", \"7\", \"aria-hidden\", \"true\", 1, \"mat-calendar-table-header-divider\"], [\"ngx-mat-calendar-body\", \"\", 3, \"label\", \"rows\", \"todayValue\", \"startValue\", \"endValue\", \"comparisonStart\", \"comparisonEnd\", \"previewStart\", \"previewEnd\", \"isRange\", \"labelMinRequiredCells\", \"activeCell\", \"selectedValueChange\", \"previewChange\", \"keydown\"], [\"scope\", \"col\"]],\n    template: function NgxMatMonthView_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"table\", 0);\n        ɵngcc0.ɵɵelementStart(1, \"thead\", 1);\n        ɵngcc0.ɵɵelementStart(2, \"tr\");\n        ɵngcc0.ɵɵtemplate(3, NgxMatMonthView_th_3_Template, 2, 2, \"th\", 2);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(4, \"tr\");\n        ɵngcc0.ɵɵelement(5, \"th\", 3);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(6, \"tbody\", 4);\n        ɵngcc0.ɵɵlistener(\"selectedValueChange\", function NgxMatMonthView_Template_tbody_selectedValueChange_6_listener($event) {\n          return ctx._dateSelected($event);\n        })(\"previewChange\", function NgxMatMonthView_Template_tbody_previewChange_6_listener($event) {\n          return ctx._previewChanged($event);\n        })(\"keydown\", function NgxMatMonthView_Template_tbody_keydown_6_listener($event) {\n          return ctx._handleCalendarBodyKeydown($event);\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx._weekdays);\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵproperty(\"label\", ctx._monthLabel)(\"rows\", ctx._weeks)(\"todayValue\", ctx._todayDate)(\"startValue\", ctx._rangeStart)(\"endValue\", ctx._rangeEnd)(\"comparisonStart\", ctx._comparisonRangeStart)(\"comparisonEnd\", ctx._comparisonRangeEnd)(\"previewStart\", ctx._previewStart)(\"previewEnd\", ctx._previewEnd)(\"isRange\", ctx._isRange)(\"labelMinRequiredCells\", 3)(\"activeCell\", ctx._dateAdapter.getDate(ctx.activeDate) - 1);\n      }\n    },\n    directives: [ɵngcc1.NgForOf, NgxMatCalendarBody],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return NgxMatMonthView;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n  NgxMatMonthView.prototype._rerenderSubscription;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatMonthView.prototype._activeDate;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatMonthView.prototype._selected;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatMonthView.prototype._minDate;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatMonthView.prototype._maxDate;\n  /**\r\n   * Function used to filter which dates are selectable.\r\n   * @type {?}\r\n   */\n\n  NgxMatMonthView.prototype.dateFilter;\n  /**\r\n   * Function that can be used to add custom CSS classes to dates.\r\n   * @type {?}\r\n   */\n\n  NgxMatMonthView.prototype.dateClass;\n  /**\r\n   * Start of the comparison range.\r\n   * @type {?}\r\n   */\n\n  NgxMatMonthView.prototype.comparisonStart;\n  /**\r\n   * End of the comparison range.\r\n   * @type {?}\r\n   */\n\n  NgxMatMonthView.prototype.comparisonEnd;\n  /**\r\n   * Emits when a new date is selected.\r\n   * @type {?}\r\n   */\n\n  NgxMatMonthView.prototype.selectedChange;\n  /**\r\n   * Emits when any date is selected.\r\n   * @type {?}\r\n   */\n\n  NgxMatMonthView.prototype._userSelection;\n  /**\r\n   * Emits when any date is activated.\r\n   * @type {?}\r\n   */\n\n  NgxMatMonthView.prototype.activeDateChange;\n  /**\r\n   * The body of calendar table\r\n   * @type {?}\r\n   */\n\n  NgxMatMonthView.prototype._matCalendarBody;\n  /**\r\n   * The label for this month (e.g. \"January 2017\").\r\n   * @type {?}\r\n   */\n\n  NgxMatMonthView.prototype._monthLabel;\n  /**\r\n   * Grid of calendar cells representing the dates of the month.\r\n   * @type {?}\r\n   */\n\n  NgxMatMonthView.prototype._weeks;\n  /**\r\n   * The number of blank cells in the first row before the 1st of the month.\r\n   * @type {?}\r\n   */\n\n  NgxMatMonthView.prototype._firstWeekOffset;\n  /**\r\n   * Start value of the currently-shown date range.\r\n   * @type {?}\r\n   */\n\n  NgxMatMonthView.prototype._rangeStart;\n  /**\r\n   * End value of the currently-shown date range.\r\n   * @type {?}\r\n   */\n\n  NgxMatMonthView.prototype._rangeEnd;\n  /**\r\n   * Start value of the currently-shown comparison date range.\r\n   * @type {?}\r\n   */\n\n  NgxMatMonthView.prototype._comparisonRangeStart;\n  /**\r\n   * End value of the currently-shown comparison date range.\r\n   * @type {?}\r\n   */\n\n  NgxMatMonthView.prototype._comparisonRangeEnd;\n  /**\r\n   * Start of the preview range.\r\n   * @type {?}\r\n   */\n\n  NgxMatMonthView.prototype._previewStart;\n  /**\r\n   * End of the preview range.\r\n   * @type {?}\r\n   */\n\n  NgxMatMonthView.prototype._previewEnd;\n  /**\r\n   * Whether the user is currently selecting a range of dates.\r\n   * @type {?}\r\n   */\n\n  NgxMatMonthView.prototype._isRange;\n  /**\r\n   * The date of the month that today falls on. Null if today is in another month.\r\n   * @type {?}\r\n   */\n\n  NgxMatMonthView.prototype._todayDate;\n  /**\r\n   * The names of the weekdays.\r\n   * @type {?}\r\n   */\n\n  NgxMatMonthView.prototype._weekdays;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatMonthView.prototype._changeDetectorRef;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatMonthView.prototype._dateFormats;\n  /** @type {?} */\n\n  NgxMatMonthView.prototype._dateAdapter;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatMonthView.prototype._dir;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatMonthView.prototype._rangeStrategy;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: lib/multi-year-view.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/** @type {?} */\n\n\nconst yearsPerPage = 24;\n/** @type {?} */\n\nconst yearsPerRow = 4;\n/**\r\n * An internal component used to display a year selector in the datepicker.\r\n * \\@docs-private\r\n * @template D\r\n */\n\nlet NgxMatMultiYearView = /*#__PURE__*/(() => {\n  class NgxMatMultiYearView {\n    /**\r\n     * @param {?} _changeDetectorRef\r\n     * @param {?} _dateAdapter\r\n     * @param {?=} _dir\r\n     */\n    constructor(_changeDetectorRef, _dateAdapter, _dir) {\n      this._changeDetectorRef = _changeDetectorRef;\n      this._dateAdapter = _dateAdapter;\n      this._dir = _dir;\n      this._rerenderSubscription = Subscription.EMPTY;\n      /**\r\n       * Emits when a new year is selected.\r\n       */\n\n      this.selectedChange = new EventEmitter();\n      /**\r\n       * Emits the selected year. This doesn't imply a change on the selected date\r\n       */\n\n      this.yearSelected = new EventEmitter();\n      /**\r\n       * Emits when any date is activated.\r\n       */\n\n      this.activeDateChange = new EventEmitter();\n\n      if (!this._dateAdapter) {\n        throw createMissingDateImplError('NgxMatDateAdapter');\n      }\n\n      this._activeDate = this._dateAdapter.today();\n    }\n    /**\r\n     * The date to display in this multi-year view (everything other than the year is ignored).\r\n     * @return {?}\r\n     */\n\n\n    get activeDate() {\n      return this._activeDate;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set activeDate(value) {\n      /** @type {?} */\n      let oldActiveDate = this._activeDate;\n      /** @type {?} */\n\n      const validDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();\n\n      this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);\n\n      if (!isSameMultiYearView(this._dateAdapter, oldActiveDate, this._activeDate, this.minDate, this.maxDate)) {\n        this._init();\n      }\n    }\n    /**\r\n     * The currently selected date.\r\n     * @return {?}\r\n     */\n\n\n    get selected() {\n      return this._selected;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set selected(value) {\n      if (value instanceof DateRange) {\n        this._selected = value;\n      } else {\n        this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n      }\n\n      this._setSelectedYear(value);\n    }\n    /**\r\n     * The minimum selectable date.\r\n     * @return {?}\r\n     */\n\n\n    get minDate() {\n      return this._minDate;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set minDate(value) {\n      this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n    /**\r\n     * The maximum selectable date.\r\n     * @return {?}\r\n     */\n\n\n    get maxDate() {\n      return this._maxDate;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set maxDate(value) {\n      this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    ngAfterContentInit() {\n      this._rerenderSubscription = this._dateAdapter.localeChanges.pipe(startWith(null)).subscribe(\n      /**\r\n      * @return {?}\r\n      */\n      () => this._init());\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    ngOnDestroy() {\n      this._rerenderSubscription.unsubscribe();\n    }\n    /**\r\n     * Initializes this multi-year view.\r\n     * @return {?}\r\n     */\n\n\n    _init() {\n      this._todayYear = this._dateAdapter.getYear(this._dateAdapter.today()); // We want a range years such that we maximize the number of\n      // enabled dates visible at once. This prevents issues where the minimum year\n      // is the last item of a page OR the maximum year is the first item of a page.\n      // The offset from the active year to the \"slot\" for the starting year is the\n      // *actual* first rendered year in the multi-year view.\n\n      /** @type {?} */\n\n      const activeYear = this._dateAdapter.getYear(this._activeDate);\n      /** @type {?} */\n\n\n      const minYearOfPage = activeYear - getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate);\n      this._years = [];\n\n      for (let i = 0, row = []; i < yearsPerPage; i++) {\n        row.push(minYearOfPage + i);\n\n        if (row.length == yearsPerRow) {\n          this._years.push(row.map(\n          /**\r\n          * @param {?} year\r\n          * @return {?}\r\n          */\n          year => this._createCellForYear(year)));\n\n          row = [];\n        }\n      }\n\n      this._changeDetectorRef.markForCheck();\n    }\n    /**\r\n     * Handles when a new year is selected.\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\n\n\n    _yearSelected(event) {\n      /** @type {?} */\n      const year = event.value;\n      this.yearSelected.emit(this._dateAdapter.createDate(year, 0, 1));\n      /** @type {?} */\n\n      let month = this._dateAdapter.getMonth(this.activeDate);\n      /** @type {?} */\n\n\n      let daysInMonth = this._dateAdapter.getNumDaysInMonth(this._dateAdapter.createDate(year, month, 1));\n\n      this.selectedChange.emit(this._dateAdapter.createDate(year, month, Math.min(this._dateAdapter.getDate(this.activeDate), daysInMonth)));\n    }\n    /**\r\n     * Handles keydown events on the calendar body when calendar is in multi-year view.\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\n\n\n    _handleCalendarBodyKeydown(event) {\n      /** @type {?} */\n      const oldActiveDate = this._activeDate;\n      /** @type {?} */\n\n      const isRtl = this._isRtl();\n\n      switch (event.keyCode) {\n        case LEFT_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, isRtl ? 1 : -1);\n          break;\n\n        case RIGHT_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, isRtl ? -1 : 1);\n          break;\n\n        case UP_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, -yearsPerRow);\n          break;\n\n        case DOWN_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, yearsPerRow);\n          break;\n\n        case HOME:\n          this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, -getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate));\n          break;\n\n        case END:\n          this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, yearsPerPage - getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate) - 1);\n          break;\n\n        case PAGE_UP:\n          this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? -yearsPerPage * 10 : -yearsPerPage);\n          break;\n\n        case PAGE_DOWN:\n          this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? yearsPerPage * 10 : yearsPerPage);\n          break;\n\n        case ENTER:\n        case SPACE:\n          this._yearSelected({\n            value: this._dateAdapter.getYear(this._activeDate),\n            event\n          });\n\n          break;\n\n        default:\n          // Don't prevent default or focus active cell on keys that we don't explicitly handle.\n          return;\n      }\n\n      if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {\n        this.activeDateChange.emit(this.activeDate);\n      }\n\n      this._focusActiveCell(); // Prevent unexpected default actions such as form submission.\n\n\n      event.preventDefault();\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    _getActiveCell() {\n      return getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate);\n    }\n    /**\r\n     * Focuses the active cell after the microtask queue is empty.\r\n     * @return {?}\r\n     */\n\n\n    _focusActiveCell() {\n      this._matCalendarBody._focusActiveCell();\n    }\n    /**\r\n     * Creates an MatCalendarCell for the given year.\r\n     * @private\r\n     * @param {?} year\r\n     * @return {?}\r\n     */\n\n\n    _createCellForYear(year) {\n      /** @type {?} */\n      let yearName = this._dateAdapter.getYearName(this._dateAdapter.createDate(year, 0, 1));\n\n      return new NgxMatCalendarCell(year, yearName, yearName, this._shouldEnableYear(year));\n    }\n    /**\r\n     * Whether the given year is enabled.\r\n     * @private\r\n     * @param {?} year\r\n     * @return {?}\r\n     */\n\n\n    _shouldEnableYear(year) {\n      // disable if the year is greater than maxDate lower than minDate\n      if (year === undefined || year === null || this.maxDate && year > this._dateAdapter.getYear(this.maxDate) || this.minDate && year < this._dateAdapter.getYear(this.minDate)) {\n        return false;\n      } // enable if it reaches here and there's no filter defined\n\n\n      if (!this.dateFilter) {\n        return true;\n      }\n      /** @type {?} */\n\n\n      const firstOfYear = this._dateAdapter.createDate(year, 0, 1); // If any date in the year is enabled count the year as enabled.\n\n\n      for (let date = firstOfYear; this._dateAdapter.getYear(date) == year; date = this._dateAdapter.addCalendarDays(date, 1)) {\n        if (this.dateFilter(date)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\r\n     * @private\r\n     * @param {?} obj The object to check.\r\n     * @return {?} The given object if it is both a date instance and valid, otherwise null.\r\n     */\n\n\n    _getValidDateOrNull(obj) {\n      return this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj) ? obj : null;\n    }\n    /**\r\n     * Determines whether the user has the RTL layout direction.\r\n     * @private\r\n     * @return {?}\r\n     */\n\n\n    _isRtl() {\n      return this._dir && this._dir.value === 'rtl';\n    }\n    /**\r\n     * Sets the currently-highlighted year based on a model value.\r\n     * @private\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    _setSelectedYear(value) {\n      this._selectedYear = null;\n\n      if (value instanceof DateRange) {\n        /** @type {?} */\n        const displayValue = value.start || value.end;\n\n        if (displayValue) {\n          this._selectedYear = this._dateAdapter.getYear(displayValue);\n        }\n      } else if (value) {\n        this._selectedYear = this._dateAdapter.getYear(value);\n      }\n    }\n\n  }\n\n  NgxMatMultiYearView.ɵfac = function NgxMatMultiYearView_Factory(t) {\n    return new (t || NgxMatMultiYearView)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(NgxMatDateAdapter, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Directionality, 8));\n  };\n\n  NgxMatMultiYearView.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: NgxMatMultiYearView,\n    selectors: [[\"ngx-mat-multi-year-view\"]],\n    viewQuery: function NgxMatMultiYearView_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(NgxMatCalendarBody, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._matCalendarBody = _t.first);\n      }\n    },\n    inputs: {\n      activeDate: \"activeDate\",\n      selected: \"selected\",\n      minDate: \"minDate\",\n      maxDate: \"maxDate\",\n      dateFilter: \"dateFilter\"\n    },\n    outputs: {\n      selectedChange: \"selectedChange\",\n      yearSelected: \"yearSelected\",\n      activeDateChange: \"activeDateChange\"\n    },\n    exportAs: [\"ngxMatMultiYearView\"],\n    decls: 5,\n    vars: 7,\n    consts: [[\"role\", \"presentation\", 1, \"mat-calendar-table\"], [1, \"mat-calendar-table-header\"], [\"colspan\", \"4\", 1, \"mat-calendar-table-header-divider\"], [\"ngx-mat-calendar-body\", \"\", 3, \"rows\", \"todayValue\", \"startValue\", \"endValue\", \"numCols\", \"cellAspectRatio\", \"activeCell\", \"selectedValueChange\", \"keydown\"]],\n    template: function NgxMatMultiYearView_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"table\", 0);\n        ɵngcc0.ɵɵelementStart(1, \"thead\", 1);\n        ɵngcc0.ɵɵelementStart(2, \"tr\");\n        ɵngcc0.ɵɵelement(3, \"th\", 2);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(4, \"tbody\", 3);\n        ɵngcc0.ɵɵlistener(\"selectedValueChange\", function NgxMatMultiYearView_Template_tbody_selectedValueChange_4_listener($event) {\n          return ctx._yearSelected($event);\n        })(\"keydown\", function NgxMatMultiYearView_Template_tbody_keydown_4_listener($event) {\n          return ctx._handleCalendarBodyKeydown($event);\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(4);\n        ɵngcc0.ɵɵproperty(\"rows\", ctx._years)(\"todayValue\", ctx._todayYear)(\"startValue\", ctx._selectedYear)(\"endValue\", ctx._selectedYear)(\"numCols\", 4)(\"cellAspectRatio\", 4 / 7)(\"activeCell\", ctx._getActiveCell());\n      }\n    },\n    directives: [NgxMatCalendarBody],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return NgxMatMultiYearView;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n  NgxMatMultiYearView.prototype._rerenderSubscription;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatMultiYearView.prototype._activeDate;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatMultiYearView.prototype._selected;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatMultiYearView.prototype._minDate;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatMultiYearView.prototype._maxDate;\n  /**\r\n   * A function used to filter which dates are selectable.\r\n   * @type {?}\r\n   */\n\n  NgxMatMultiYearView.prototype.dateFilter;\n  /**\r\n   * Emits when a new year is selected.\r\n   * @type {?}\r\n   */\n\n  NgxMatMultiYearView.prototype.selectedChange;\n  /**\r\n   * Emits the selected year. This doesn't imply a change on the selected date\r\n   * @type {?}\r\n   */\n\n  NgxMatMultiYearView.prototype.yearSelected;\n  /**\r\n   * Emits when any date is activated.\r\n   * @type {?}\r\n   */\n\n  NgxMatMultiYearView.prototype.activeDateChange;\n  /**\r\n   * The body of calendar table\r\n   * @type {?}\r\n   */\n\n  NgxMatMultiYearView.prototype._matCalendarBody;\n  /**\r\n   * Grid of calendar cells representing the currently displayed years.\r\n   * @type {?}\r\n   */\n\n  NgxMatMultiYearView.prototype._years;\n  /**\r\n   * The year that today falls on.\r\n   * @type {?}\r\n   */\n\n  NgxMatMultiYearView.prototype._todayYear;\n  /**\r\n   * The year of the selected date. Null if the selected date is null.\r\n   * @type {?}\r\n   */\n\n  NgxMatMultiYearView.prototype._selectedYear;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatMultiYearView.prototype._changeDetectorRef;\n  /** @type {?} */\n\n  NgxMatMultiYearView.prototype._dateAdapter;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatMultiYearView.prototype._dir;\n}\n/**\r\n * @template D\r\n * @param {?} dateAdapter\r\n * @param {?} date1\r\n * @param {?} date2\r\n * @param {?} minDate\r\n * @param {?} maxDate\r\n * @return {?}\r\n */\n\n\nfunction isSameMultiYearView(dateAdapter, date1, date2, minDate, maxDate) {\n  /** @type {?} */\n  const year1 = dateAdapter.getYear(date1);\n  /** @type {?} */\n\n  const year2 = dateAdapter.getYear(date2);\n  /** @type {?} */\n\n  const startingYear = getStartingYear(dateAdapter, minDate, maxDate);\n  return Math.floor((year1 - startingYear) / yearsPerPage) === Math.floor((year2 - startingYear) / yearsPerPage);\n}\n/**\r\n * When the multi-year view is first opened, the active year will be in view.\r\n * So we compute how many years are between the active year and the *slot* where our\r\n * \"startingYear\" will render when paged into view.\r\n * @template D\r\n * @param {?} dateAdapter\r\n * @param {?} activeDate\r\n * @param {?} minDate\r\n * @param {?} maxDate\r\n * @return {?}\r\n */\n\n\nfunction getActiveOffset(dateAdapter, activeDate, minDate, maxDate) {\n  /** @type {?} */\n  const activeYear = dateAdapter.getYear(activeDate);\n  return euclideanModulo(activeYear - getStartingYear(dateAdapter, minDate, maxDate), yearsPerPage);\n}\n/**\r\n * We pick a \"starting\" year such that either the maximum year would be at the end\r\n * or the minimum year would be at the beginning of a page.\r\n * @template D\r\n * @param {?} dateAdapter\r\n * @param {?} minDate\r\n * @param {?} maxDate\r\n * @return {?}\r\n */\n\n\nfunction getStartingYear(dateAdapter, minDate, maxDate) {\n  /** @type {?} */\n  let startingYear = 0;\n\n  if (maxDate) {\n    /** @type {?} */\n    const maxYear = dateAdapter.getYear(maxDate);\n    startingYear = maxYear - yearsPerPage + 1;\n  } else if (minDate) {\n    startingYear = dateAdapter.getYear(minDate);\n  }\n\n  return startingYear;\n}\n/**\r\n * Gets remainder that is non-negative, even if first number is negative\r\n * @param {?} a\r\n * @param {?} b\r\n * @return {?}\r\n */\n\n\nfunction euclideanModulo(a, b) {\n  return (a % b + b) % b;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: lib/year-view.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * An internal component used to display a single year in the datepicker.\r\n * \\@docs-private\r\n * @template D\r\n */\n\n\nlet NgxMatYearView = /*#__PURE__*/(() => {\n  class NgxMatYearView {\n    /**\r\n     * @param {?} _changeDetectorRef\r\n     * @param {?} _dateFormats\r\n     * @param {?} _dateAdapter\r\n     * @param {?=} _dir\r\n     */\n    constructor(_changeDetectorRef, _dateFormats, _dateAdapter, _dir) {\n      this._changeDetectorRef = _changeDetectorRef;\n      this._dateFormats = _dateFormats;\n      this._dateAdapter = _dateAdapter;\n      this._dir = _dir;\n      this._rerenderSubscription = Subscription.EMPTY;\n      /**\r\n       * Emits when a new month is selected.\r\n       */\n\n      this.selectedChange = new EventEmitter();\n      /**\r\n       * Emits the selected month. This doesn't imply a change on the selected date\r\n       */\n\n      this.monthSelected = new EventEmitter();\n      /**\r\n       * Emits when any date is activated.\r\n       */\n\n      this.activeDateChange = new EventEmitter();\n\n      if (!this._dateAdapter) {\n        throw createMissingDateImplError('NgxMatDateAdapter');\n      }\n\n      if (!this._dateFormats) {\n        throw createMissingDateImplError('NGX_MAT_DATE_FORMATS');\n      }\n\n      this._activeDate = this._dateAdapter.today();\n    }\n    /**\r\n     * The date to display in this year view (everything other than the year is ignored).\r\n     * @return {?}\r\n     */\n\n\n    get activeDate() {\n      return this._activeDate;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set activeDate(value) {\n      /** @type {?} */\n      let oldActiveDate = this._activeDate;\n      /** @type {?} */\n\n      const validDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();\n\n      this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);\n\n      if (this._dateAdapter.getYear(oldActiveDate) !== this._dateAdapter.getYear(this._activeDate)) {\n        this._init();\n      }\n    }\n    /**\r\n     * The currently selected date.\r\n     * @return {?}\r\n     */\n\n\n    get selected() {\n      return this._selected;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set selected(value) {\n      if (value instanceof DateRange) {\n        this._selected = value;\n      } else {\n        this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n      }\n\n      this._setSelectedMonth(value);\n    }\n    /**\r\n     * The minimum selectable date.\r\n     * @return {?}\r\n     */\n\n\n    get minDate() {\n      return this._minDate;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set minDate(value) {\n      this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n    /**\r\n     * The maximum selectable date.\r\n     * @return {?}\r\n     */\n\n\n    get maxDate() {\n      return this._maxDate;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set maxDate(value) {\n      this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    ngAfterContentInit() {\n      this._rerenderSubscription = this._dateAdapter.localeChanges.pipe(startWith(null)).subscribe(\n      /**\r\n      * @return {?}\r\n      */\n      () => this._init());\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    ngOnDestroy() {\n      this._rerenderSubscription.unsubscribe();\n    }\n    /**\r\n     * Handles when a new month is selected.\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\n\n\n    _monthSelected(event) {\n      /** @type {?} */\n      const month = event.value;\n      /** @type {?} */\n\n      const normalizedDate = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, 1);\n\n      this.monthSelected.emit(normalizedDate);\n      /** @type {?} */\n\n      const daysInMonth = this._dateAdapter.getNumDaysInMonth(normalizedDate);\n\n      this.selectedChange.emit(this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, Math.min(this._dateAdapter.getDate(this.activeDate), daysInMonth)));\n    }\n    /**\r\n     * Handles keydown events on the calendar body when calendar is in year view.\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\n\n\n    _handleCalendarBodyKeydown(event) {\n      // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent\n      // disabled ones from being selected. This may not be ideal, we should look into whether\n      // navigation should skip over disabled dates, and if so, how to implement that efficiently.\n      // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent\n      // disabled ones from being selected. This may not be ideal, we should look into whether\n      // navigation should skip over disabled dates, and if so, how to implement that efficiently.\n\n      /** @type {?} */\n      const oldActiveDate = this._activeDate;\n      /** @type {?} */\n\n      const isRtl = this._isRtl();\n\n      switch (event.keyCode) {\n        case LEFT_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, isRtl ? 1 : -1);\n          break;\n\n        case RIGHT_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, isRtl ? -1 : 1);\n          break;\n\n        case UP_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, -4);\n          break;\n\n        case DOWN_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, 4);\n          break;\n\n        case HOME:\n          this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, -this._dateAdapter.getMonth(this._activeDate));\n          break;\n\n        case END:\n          this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, 11 - this._dateAdapter.getMonth(this._activeDate));\n          break;\n\n        case PAGE_UP:\n          this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? -10 : -1);\n          break;\n\n        case PAGE_DOWN:\n          this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? 10 : 1);\n          break;\n\n        case ENTER:\n        case SPACE:\n          this._monthSelected({\n            value: this._dateAdapter.getMonth(this._activeDate),\n            event\n          });\n\n          break;\n\n        default:\n          // Don't prevent default or focus active cell on keys that we don't explicitly handle.\n          return;\n      }\n\n      if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {\n        this.activeDateChange.emit(this.activeDate);\n      }\n\n      this._focusActiveCell(); // Prevent unexpected default actions such as form submission.\n\n\n      event.preventDefault();\n    }\n    /**\r\n     * Initializes this year view.\r\n     * @return {?}\r\n     */\n\n\n    _init() {\n      this._setSelectedMonth(this.selected);\n\n      this._todayMonth = this._getMonthInCurrentYear(this._dateAdapter.today());\n      this._yearLabel = this._dateAdapter.getYearName(this.activeDate);\n      /** @type {?} */\n\n      let monthNames = this._dateAdapter.getMonthNames('short'); // First row of months only contains 5 elements so we can fit the year label on the same row.\n\n\n      this._months = [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]].map(\n      /**\r\n      * @param {?} row\r\n      * @return {?}\r\n      */\n      row => row.map(\n      /**\r\n      * @param {?} month\r\n      * @return {?}\r\n      */\n      month => this._createCellForMonth(month, monthNames[month])));\n\n      this._changeDetectorRef.markForCheck();\n    }\n    /**\r\n     * Focuses the active cell after the microtask queue is empty.\r\n     * @return {?}\r\n     */\n\n\n    _focusActiveCell() {\n      this._matCalendarBody._focusActiveCell();\n    }\n    /**\r\n     * Gets the month in this year that the given Date falls on.\r\n     * Returns null if the given Date is in another year.\r\n     * @private\r\n     * @param {?} date\r\n     * @return {?}\r\n     */\n\n\n    _getMonthInCurrentYear(date) {\n      return date && this._dateAdapter.getYear(date) == this._dateAdapter.getYear(this.activeDate) ? this._dateAdapter.getMonth(date) : null;\n    }\n    /**\r\n     * Creates an MatCalendarCell for the given month.\r\n     * @private\r\n     * @param {?} month\r\n     * @param {?} monthName\r\n     * @return {?}\r\n     */\n\n\n    _createCellForMonth(month, monthName) {\n      /** @type {?} */\n      let ariaLabel = this._dateAdapter.format(this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, 1), this._dateFormats.display.monthYearA11yLabel);\n\n      return new NgxMatCalendarCell(month, monthName.toLocaleUpperCase(), ariaLabel, this._shouldEnableMonth(month));\n    }\n    /**\r\n     * Whether the given month is enabled.\r\n     * @private\r\n     * @param {?} month\r\n     * @return {?}\r\n     */\n\n\n    _shouldEnableMonth(month) {\n      /** @type {?} */\n      const activeYear = this._dateAdapter.getYear(this.activeDate);\n\n      if (month === undefined || month === null || this._isYearAndMonthAfterMaxDate(activeYear, month) || this._isYearAndMonthBeforeMinDate(activeYear, month)) {\n        return false;\n      }\n\n      if (!this.dateFilter) {\n        return true;\n      }\n      /** @type {?} */\n\n\n      const firstOfMonth = this._dateAdapter.createDate(activeYear, month, 1); // If any date in the month is enabled count the month as enabled.\n\n\n      for (let date = firstOfMonth; this._dateAdapter.getMonth(date) == month; date = this._dateAdapter.addCalendarDays(date, 1)) {\n        if (this.dateFilter(date)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\r\n     * Tests whether the combination month/year is after this.maxDate, considering\r\n     * just the month and year of this.maxDate\r\n     * @private\r\n     * @param {?} year\r\n     * @param {?} month\r\n     * @return {?}\r\n     */\n\n\n    _isYearAndMonthAfterMaxDate(year, month) {\n      if (this.maxDate) {\n        /** @type {?} */\n        const maxYear = this._dateAdapter.getYear(this.maxDate);\n        /** @type {?} */\n\n\n        const maxMonth = this._dateAdapter.getMonth(this.maxDate);\n\n        return year > maxYear || year === maxYear && month > maxMonth;\n      }\n\n      return false;\n    }\n    /**\r\n     * Tests whether the combination month/year is before this.minDate, considering\r\n     * just the month and year of this.minDate\r\n     * @private\r\n     * @param {?} year\r\n     * @param {?} month\r\n     * @return {?}\r\n     */\n\n\n    _isYearAndMonthBeforeMinDate(year, month) {\n      if (this.minDate) {\n        /** @type {?} */\n        const minYear = this._dateAdapter.getYear(this.minDate);\n        /** @type {?} */\n\n\n        const minMonth = this._dateAdapter.getMonth(this.minDate);\n\n        return year < minYear || year === minYear && month < minMonth;\n      }\n\n      return false;\n    }\n    /**\r\n     * @private\r\n     * @param {?} obj The object to check.\r\n     * @return {?} The given object if it is both a date instance and valid, otherwise null.\r\n     */\n\n\n    _getValidDateOrNull(obj) {\n      return this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj) ? obj : null;\n    }\n    /**\r\n     * Determines whether the user has the RTL layout direction.\r\n     * @private\r\n     * @return {?}\r\n     */\n\n\n    _isRtl() {\n      return this._dir && this._dir.value === 'rtl';\n    }\n    /**\r\n     * Sets the currently-selected month based on a model value.\r\n     * @private\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    _setSelectedMonth(value) {\n      if (value instanceof DateRange) {\n        this._selectedMonth = this._getMonthInCurrentYear(value.start) || this._getMonthInCurrentYear(value.end);\n      } else {\n        this._selectedMonth = this._getMonthInCurrentYear(value);\n      }\n    }\n\n  }\n\n  NgxMatYearView.ɵfac = function NgxMatYearView_Factory(t) {\n    return new (t || NgxMatYearView)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(NGX_MAT_DATE_FORMATS, 8), ɵngcc0.ɵɵdirectiveInject(NgxMatDateAdapter, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Directionality, 8));\n  };\n\n  NgxMatYearView.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: NgxMatYearView,\n    selectors: [[\"ngx-mat-year-view\"]],\n    viewQuery: function NgxMatYearView_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(NgxMatCalendarBody, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._matCalendarBody = _t.first);\n      }\n    },\n    inputs: {\n      activeDate: \"activeDate\",\n      selected: \"selected\",\n      minDate: \"minDate\",\n      maxDate: \"maxDate\",\n      dateFilter: \"dateFilter\"\n    },\n    outputs: {\n      selectedChange: \"selectedChange\",\n      monthSelected: \"monthSelected\",\n      activeDateChange: \"activeDateChange\"\n    },\n    exportAs: [\"ngxMatYearView\"],\n    decls: 5,\n    vars: 9,\n    consts: [[\"role\", \"presentation\", 1, \"mat-calendar-table\"], [1, \"mat-calendar-table-header\"], [\"colspan\", \"4\", 1, \"mat-calendar-table-header-divider\"], [\"ngx-mat-calendar-body\", \"\", 3, \"label\", \"rows\", \"todayValue\", \"startValue\", \"endValue\", \"labelMinRequiredCells\", \"numCols\", \"cellAspectRatio\", \"activeCell\", \"selectedValueChange\", \"keydown\"]],\n    template: function NgxMatYearView_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"table\", 0);\n        ɵngcc0.ɵɵelementStart(1, \"thead\", 1);\n        ɵngcc0.ɵɵelementStart(2, \"tr\");\n        ɵngcc0.ɵɵelement(3, \"th\", 2);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(4, \"tbody\", 3);\n        ɵngcc0.ɵɵlistener(\"selectedValueChange\", function NgxMatYearView_Template_tbody_selectedValueChange_4_listener($event) {\n          return ctx._monthSelected($event);\n        })(\"keydown\", function NgxMatYearView_Template_tbody_keydown_4_listener($event) {\n          return ctx._handleCalendarBodyKeydown($event);\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(4);\n        ɵngcc0.ɵɵproperty(\"label\", ctx._yearLabel)(\"rows\", ctx._months)(\"todayValue\", ctx._todayMonth)(\"startValue\", ctx._selectedMonth)(\"endValue\", ctx._selectedMonth)(\"labelMinRequiredCells\", 2)(\"numCols\", 4)(\"cellAspectRatio\", 4 / 7)(\"activeCell\", ctx._dateAdapter.getMonth(ctx.activeDate));\n      }\n    },\n    directives: [NgxMatCalendarBody],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return NgxMatYearView;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n  NgxMatYearView.prototype._rerenderSubscription;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatYearView.prototype._activeDate;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatYearView.prototype._selected;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatYearView.prototype._minDate;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatYearView.prototype._maxDate;\n  /**\r\n   * A function used to filter which dates are selectable.\r\n   * @type {?}\r\n   */\n\n  NgxMatYearView.prototype.dateFilter;\n  /**\r\n   * Emits when a new month is selected.\r\n   * @type {?}\r\n   */\n\n  NgxMatYearView.prototype.selectedChange;\n  /**\r\n   * Emits the selected month. This doesn't imply a change on the selected date\r\n   * @type {?}\r\n   */\n\n  NgxMatYearView.prototype.monthSelected;\n  /**\r\n   * Emits when any date is activated.\r\n   * @type {?}\r\n   */\n\n  NgxMatYearView.prototype.activeDateChange;\n  /**\r\n   * The body of calendar table\r\n   * @type {?}\r\n   */\n\n  NgxMatYearView.prototype._matCalendarBody;\n  /**\r\n   * Grid of calendar cells representing the months of the year.\r\n   * @type {?}\r\n   */\n\n  NgxMatYearView.prototype._months;\n  /**\r\n   * The label for this year (e.g. \"2017\").\r\n   * @type {?}\r\n   */\n\n  NgxMatYearView.prototype._yearLabel;\n  /**\r\n   * The month in this year that today falls on. Null if today is in a different year.\r\n   * @type {?}\r\n   */\n\n  NgxMatYearView.prototype._todayMonth;\n  /**\r\n   * The month in this year that the selected Date falls on.\r\n   * Null if the selected Date is in a different year.\r\n   * @type {?}\r\n   */\n\n  NgxMatYearView.prototype._selectedMonth;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatYearView.prototype._changeDetectorRef;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatYearView.prototype._dateFormats;\n  /** @type {?} */\n\n  NgxMatYearView.prototype._dateAdapter;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatYearView.prototype._dir;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: lib/calendar.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * Default header for NgxMatCalendar\r\n * @template D\r\n */\n\n\nlet NgxMatCalendarHeader = /*#__PURE__*/(() => {\n  class NgxMatCalendarHeader {\n    /**\r\n     * @param {?} _intl\r\n     * @param {?} calendar\r\n     * @param {?} _dateAdapter\r\n     * @param {?} _dateFormats\r\n     * @param {?} changeDetectorRef\r\n     */\n    constructor(_intl, calendar, _dateAdapter, _dateFormats, changeDetectorRef) {\n      this._intl = _intl;\n      this.calendar = calendar;\n      this._dateAdapter = _dateAdapter;\n      this._dateFormats = _dateFormats;\n      this.calendar.stateChanges.subscribe(\n      /**\r\n      * @return {?}\r\n      */\n      () => changeDetectorRef.markForCheck());\n    }\n    /**\r\n     * The label for the current calendar view.\r\n     * @return {?}\r\n     */\n\n\n    get periodButtonText() {\n      if (this.calendar.currentView == 'month') {\n        return this._dateAdapter.format(this.calendar.activeDate, this._dateFormats.display.monthYearLabel).toLocaleUpperCase();\n      }\n\n      if (this.calendar.currentView == 'year') {\n        return this._dateAdapter.getYearName(this.calendar.activeDate);\n      } // The offset from the active year to the \"slot\" for the starting year is the\n      // *actual* first rendered year in the multi-year view, and the last year is\n      // just yearsPerPage - 1 away.\n\n      /** @type {?} */\n\n\n      const activeYear = this._dateAdapter.getYear(this.calendar.activeDate);\n      /** @type {?} */\n\n\n      const minYearOfPage = activeYear - getActiveOffset(this._dateAdapter, this.calendar.activeDate, this.calendar.minDate, this.calendar.maxDate);\n      /** @type {?} */\n\n      const maxYearOfPage = minYearOfPage + yearsPerPage - 1;\n      /** @type {?} */\n\n      const minYearName = this._dateAdapter.getYearName(this._dateAdapter.createDate(minYearOfPage, 0, 1));\n      /** @type {?} */\n\n\n      const maxYearName = this._dateAdapter.getYearName(this._dateAdapter.createDate(maxYearOfPage, 0, 1));\n\n      return formatYearRange(minYearName, maxYearName);\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    get periodButtonLabel() {\n      return this.calendar.currentView == 'month' ? this._intl.switchToMultiYearViewLabel : this._intl.switchToMonthViewLabel;\n    }\n    /**\r\n     * The label for the previous button.\r\n     * @return {?}\r\n     */\n\n\n    get prevButtonLabel() {\n      return {\n        'month': this._intl.prevMonthLabel,\n        'year': this._intl.prevYearLabel,\n        'multi-year': this._intl.prevMultiYearLabel\n      }[this.calendar.currentView];\n    }\n    /**\r\n     * The label for the next button.\r\n     * @return {?}\r\n     */\n\n\n    get nextButtonLabel() {\n      return {\n        'month': this._intl.nextMonthLabel,\n        'year': this._intl.nextYearLabel,\n        'multi-year': this._intl.nextMultiYearLabel\n      }[this.calendar.currentView];\n    }\n    /**\r\n     * Handles user clicks on the period label.\r\n     * @return {?}\r\n     */\n\n\n    currentPeriodClicked() {\n      this.calendar.currentView = this.calendar.currentView == 'month' ? 'multi-year' : 'month';\n    }\n    /**\r\n     * Handles user clicks on the previous button.\r\n     * @return {?}\r\n     */\n\n\n    previousClicked() {\n      this.calendar.activeDate = this.calendar.currentView == 'month' ? this._dateAdapter.addCalendarMonths(this.calendar.activeDate, -1) : this._dateAdapter.addCalendarYears(this.calendar.activeDate, this.calendar.currentView == 'year' ? -1 : -yearsPerPage);\n    }\n    /**\r\n     * Handles user clicks on the next button.\r\n     * @return {?}\r\n     */\n\n\n    nextClicked() {\n      this.calendar.activeDate = this.calendar.currentView == 'month' ? this._dateAdapter.addCalendarMonths(this.calendar.activeDate, 1) : this._dateAdapter.addCalendarYears(this.calendar.activeDate, this.calendar.currentView == 'year' ? 1 : yearsPerPage);\n    }\n    /**\r\n     * Whether the previous period button is enabled.\r\n     * @return {?}\r\n     */\n\n\n    previousEnabled() {\n      if (!this.calendar.minDate) {\n        return true;\n      }\n\n      return !this.calendar.minDate || !this._isSameView(this.calendar.activeDate, this.calendar.minDate);\n    }\n    /**\r\n     * Whether the next period button is enabled.\r\n     * @return {?}\r\n     */\n\n\n    nextEnabled() {\n      return !this.calendar.maxDate || !this._isSameView(this.calendar.activeDate, this.calendar.maxDate);\n    }\n    /**\r\n     * Whether the two dates represent the same view in the current view mode (month or year).\r\n     * @private\r\n     * @param {?} date1\r\n     * @param {?} date2\r\n     * @return {?}\r\n     */\n\n\n    _isSameView(date1, date2) {\n      if (this.calendar.currentView == 'month') {\n        return this._dateAdapter.getYear(date1) == this._dateAdapter.getYear(date2) && this._dateAdapter.getMonth(date1) == this._dateAdapter.getMonth(date2);\n      }\n\n      if (this.calendar.currentView == 'year') {\n        return this._dateAdapter.getYear(date1) == this._dateAdapter.getYear(date2);\n      } // Otherwise we are in 'multi-year' view.\n\n\n      return isSameMultiYearView(this._dateAdapter, date1, date2, this.calendar.minDate, this.calendar.maxDate);\n    }\n\n  }\n\n  NgxMatCalendarHeader.ɵfac = function NgxMatCalendarHeader_Factory(t) {\n    return new (t || NgxMatCalendarHeader)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.MatDatepickerIntl), ɵngcc0.ɵɵdirectiveInject(forwardRef(\n    /**\n    * @return {?}\n    */\n    () => NgxMatCalendar)), ɵngcc0.ɵɵdirectiveInject(NgxMatDateAdapter, 8), ɵngcc0.ɵɵdirectiveInject(NGX_MAT_DATE_FORMATS, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n  };\n\n  NgxMatCalendarHeader.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: NgxMatCalendarHeader,\n    selectors: [[\"ngx-mat-calendar-header\"]],\n    exportAs: [\"ngxMatCalendarHeader\"],\n    ngContentSelectors: _c1,\n    decls: 9,\n    vars: 8,\n    consts: [[1, \"mat-calendar-header\"], [1, \"mat-calendar-controls\"], [\"mat-button\", \"\", \"type\", \"button\", \"cdkAriaLive\", \"polite\", 1, \"mat-calendar-period-button\", 3, \"click\"], [1, \"mat-calendar-arrow\"], [1, \"mat-calendar-spacer\"], [\"mat-icon-button\", \"\", \"type\", \"button\", 1, \"mat-calendar-previous-button\", 3, \"disabled\", \"click\"], [\"mat-icon-button\", \"\", \"type\", \"button\", 1, \"mat-calendar-next-button\", 3, \"disabled\", \"click\"]],\n    template: function NgxMatCalendarHeader_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵelementStart(1, \"div\", 1);\n        ɵngcc0.ɵɵelementStart(2, \"button\", 2);\n        ɵngcc0.ɵɵlistener(\"click\", function NgxMatCalendarHeader_Template_button_click_2_listener() {\n          return ctx.currentPeriodClicked();\n        });\n        ɵngcc0.ɵɵtext(3);\n        ɵngcc0.ɵɵelement(4, \"div\", 3);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelement(5, \"div\", 4);\n        ɵngcc0.ɵɵprojection(6);\n        ɵngcc0.ɵɵelementStart(7, \"button\", 5);\n        ɵngcc0.ɵɵlistener(\"click\", function NgxMatCalendarHeader_Template_button_click_7_listener() {\n          return ctx.previousClicked();\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(8, \"button\", 6);\n        ɵngcc0.ɵɵlistener(\"click\", function NgxMatCalendarHeader_Template_button_click_8_listener() {\n          return ctx.nextClicked();\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵattribute(\"aria-label\", ctx.periodButtonLabel);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵtextInterpolate1(\" \", ctx.periodButtonText, \" \");\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵclassProp(\"mat-calendar-invert\", ctx.calendar.currentView != \"month\");\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵproperty(\"disabled\", !ctx.previousEnabled());\n        ɵngcc0.ɵɵattribute(\"aria-label\", ctx.prevButtonLabel);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"disabled\", !ctx.nextEnabled());\n        ɵngcc0.ɵɵattribute(\"aria-label\", ctx.nextButtonLabel);\n      }\n    },\n    directives: [ɵngcc4.MatButton],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return NgxMatCalendarHeader;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n  NgxMatCalendarHeader.prototype._intl;\n  /** @type {?} */\n\n  NgxMatCalendarHeader.prototype.calendar;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatCalendarHeader.prototype._dateAdapter;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatCalendarHeader.prototype._dateFormats;\n}\n/**\r\n * A calendar that is used as part of the datepicker.\r\n * \\@docs-private\r\n * @template D\r\n */\n\n\nlet NgxMatCalendar = /*#__PURE__*/(() => {\n  class NgxMatCalendar {\n    /**\r\n     * @param {?} _intl\r\n     * @param {?} _dateAdapter\r\n     * @param {?} _dateFormats\r\n     * @param {?} _changeDetectorRef\r\n     */\n    constructor(_intl, _dateAdapter, _dateFormats, _changeDetectorRef) {\n      this._dateAdapter = _dateAdapter;\n      this._dateFormats = _dateFormats;\n      this._changeDetectorRef = _changeDetectorRef;\n      /**\r\n       * Used for scheduling that focus should be moved to the active cell on the next tick.\r\n       * We need to schedule it, rather than do it immediately, because we have to wait\r\n       * for Angular to re-evaluate the view children.\r\n       */\n\n      this._moveFocusOnNextTick = false;\n      /**\r\n       * Whether the calendar should be started in month or year view.\r\n       */\n\n      this.startView = 'month';\n      /**\r\n       * Emits when the currently selected date changes.\r\n       */\n\n      this.selectedChange = new EventEmitter();\n      /**\r\n       * Emits the year chosen in multiyear view.\r\n       * This doesn't imply a change on the selected date.\r\n       */\n\n      this.yearSelected = new EventEmitter();\n      /**\r\n       * Emits the month chosen in year view.\r\n       * This doesn't imply a change on the selected date.\r\n       */\n\n      this.monthSelected = new EventEmitter();\n      /**\r\n       * Emits when any date is selected.\r\n       */\n\n      this._userSelection = new EventEmitter();\n      /**\r\n       * Emits whenever there is a state change that the header may need to respond to.\r\n       */\n\n      this.stateChanges = new Subject();\n\n      if (!this._dateAdapter) {\n        throw createMissingDateImplError('NgxDateAdapter');\n      }\n\n      if (!this._dateFormats) {\n        throw createMissingDateImplError('NGX_MAT_DATE_FORMATS');\n      }\n\n      this._intlChanges = _intl.changes.subscribe(\n      /**\r\n      * @return {?}\r\n      */\n      () => {\n        _changeDetectorRef.markForCheck();\n\n        this.stateChanges.next();\n      });\n    }\n    /**\r\n     * A date representing the period (month or year) to start the calendar in.\r\n     * @return {?}\r\n     */\n\n\n    get startAt() {\n      return this._startAt;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set startAt(value) {\n      this._startAt = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n    /**\r\n     * The currently selected date.\r\n     * @return {?}\r\n     */\n\n\n    get selected() {\n      return this._selected;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set selected(value) {\n      this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n    /**\r\n     * The minimum selectable date.\r\n     * @return {?}\r\n     */\n\n\n    get minDate() {\n      return this._minDate;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set minDate(value) {\n      this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n    /**\r\n     * The maximum selectable date.\r\n     * @return {?}\r\n     */\n\n\n    get maxDate() {\n      return this._maxDate;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set maxDate(value) {\n      this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n    /**\r\n     * The current active date. This determines which time period is shown and which date is\r\n     * highlighted when using keyboard navigation.\r\n     * @return {?}\r\n     */\n\n\n    get activeDate() {\n      return this._clampedActiveDate;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set activeDate(value) {\n      this._clampedActiveDate = this._dateAdapter.clampDate(value, this.minDate, this.maxDate);\n      this.stateChanges.next();\n\n      this._changeDetectorRef.markForCheck();\n    }\n    /**\r\n     * Whether the calendar is in month view.\r\n     * @return {?}\r\n     */\n\n\n    get currentView() {\n      return this._currentView;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set currentView(value) {\n      this._currentView = value;\n      this._moveFocusOnNextTick = true;\n\n      this._changeDetectorRef.markForCheck();\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    ngAfterContentInit() {\n      this._calendarHeaderPortal = new ComponentPortal(this.headerComponent || NgxMatCalendarHeader);\n      this.activeDate = this.startAt || this._dateAdapter.today(); // Assign to the private property since we don't want to move focus on init.\n\n      this._currentView = this.startView;\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    ngAfterViewChecked() {\n      if (this._moveFocusOnNextTick) {\n        this._moveFocusOnNextTick = false;\n        this.focusActiveCell();\n      }\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    ngOnDestroy() {\n      this._intlChanges.unsubscribe();\n\n      this.stateChanges.complete();\n    }\n    /**\r\n     * @param {?} changes\r\n     * @return {?}\r\n     */\n\n\n    ngOnChanges(changes) {\n      /** @type {?} */\n      const change = changes['minDate'] || changes['maxDate'] || changes['dateFilter'];\n\n      if (change && !change.firstChange) {\n        /** @type {?} */\n        const view = this._getCurrentViewComponent();\n\n        if (view) {\n          // We need to `detectChanges` manually here, because the `minDate`, `maxDate` etc. are\n          // passed down to the view via data bindings which won't be up-to-date when we call `_init`.\n          this._changeDetectorRef.detectChanges();\n\n          view._init();\n        }\n      }\n\n      this.stateChanges.next();\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    focusActiveCell() {\n      this._getCurrentViewComponent()._focusActiveCell();\n    }\n    /**\r\n     * Updates today's date after an update of the active date\r\n     * @return {?}\r\n     */\n\n\n    updateTodaysDate() {\n      /** @type {?} */\n      let view = this.currentView == 'month' ? this.monthView : this.currentView == 'year' ? this.yearView : this.multiYearView;\n      view.ngAfterContentInit();\n    }\n    /**\r\n     * Handles date selection in the month view.\r\n     * @param {?} date\r\n     * @return {?}\r\n     */\n\n\n    _dateSelected(date) {\n      if (date && !this._dateAdapter.sameDate(date, this.selected)) {\n        this.selectedChange.emit(date);\n      }\n    }\n    /**\r\n     * Handles year selection in the multiyear view.\r\n     * @param {?} normalizedYear\r\n     * @return {?}\r\n     */\n\n\n    _yearSelectedInMultiYearView(normalizedYear) {\n      this.yearSelected.emit(normalizedYear);\n    }\n    /**\r\n     * Handles month selection in the year view.\r\n     * @param {?} normalizedMonth\r\n     * @return {?}\r\n     */\n\n\n    _monthSelectedInYearView(normalizedMonth) {\n      this.monthSelected.emit(normalizedMonth);\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    _userSelected() {\n      this._userSelection.emit();\n    }\n    /**\r\n     * Handles year/month selection in the multi-year/year views.\r\n     * @param {?} date\r\n     * @param {?} view\r\n     * @return {?}\r\n     */\n\n\n    _goToDateInView(date, view) {\n      this.activeDate = date;\n      this.currentView = view;\n    }\n    /**\r\n     * @private\r\n     * @param {?} obj The object to check.\r\n     * @return {?} The given object if it is both a date instance and valid, otherwise null.\r\n     */\n\n\n    _getValidDateOrNull(obj) {\n      return this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj) ? obj : null;\n    }\n    /**\r\n     * Returns the component instance that corresponds to the current calendar view.\r\n     * @private\r\n     * @return {?}\r\n     */\n\n\n    _getCurrentViewComponent() {\n      return this.monthView || this.yearView || this.multiYearView;\n    }\n\n  }\n\n  NgxMatCalendar.ɵfac = function NgxMatCalendar_Factory(t) {\n    return new (t || NgxMatCalendar)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.MatDatepickerIntl), ɵngcc0.ɵɵdirectiveInject(NgxMatDateAdapter, 8), ɵngcc0.ɵɵdirectiveInject(NGX_MAT_DATE_FORMATS, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n  };\n\n  NgxMatCalendar.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: NgxMatCalendar,\n    selectors: [[\"ngx-mat-calendar\"]],\n    viewQuery: function NgxMatCalendar_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(NgxMatMonthView, 5);\n        ɵngcc0.ɵɵviewQuery(NgxMatYearView, 5);\n        ɵngcc0.ɵɵviewQuery(NgxMatMultiYearView, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.monthView = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.yearView = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.multiYearView = _t.first);\n      }\n    },\n    hostAttrs: [1, \"mat-calendar\"],\n    inputs: {\n      startView: \"startView\",\n      startAt: \"startAt\",\n      selected: \"selected\",\n      minDate: \"minDate\",\n      maxDate: \"maxDate\",\n      headerComponent: \"headerComponent\",\n      dateFilter: \"dateFilter\",\n      dateClass: \"dateClass\"\n    },\n    outputs: {\n      selectedChange: \"selectedChange\",\n      yearSelected: \"yearSelected\",\n      monthSelected: \"monthSelected\",\n      _userSelection: \"_userSelection\"\n    },\n    exportAs: [\"ngxMatCalendar\"],\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 5,\n    vars: 5,\n    consts: [[3, \"cdkPortalOutlet\"], [\"cdkMonitorSubtreeFocus\", \"\", \"tabindex\", \"-1\", 1, \"mat-calendar-content\", 3, \"ngSwitch\"], [3, \"activeDate\", \"selected\", \"dateFilter\", \"maxDate\", \"minDate\", \"dateClass\", \"activeDateChange\", \"selectedChange\", \"_userSelection\", 4, \"ngSwitchCase\"], [3, \"activeDate\", \"selected\", \"dateFilter\", \"maxDate\", \"minDate\", \"activeDateChange\", \"monthSelected\", \"selectedChange\", 4, \"ngSwitchCase\"], [3, \"activeDate\", \"selected\", \"dateFilter\", \"maxDate\", \"minDate\", \"activeDateChange\", \"yearSelected\", \"selectedChange\", 4, \"ngSwitchCase\"], [3, \"activeDate\", \"selected\", \"dateFilter\", \"maxDate\", \"minDate\", \"dateClass\", \"activeDateChange\", \"selectedChange\", \"_userSelection\"], [3, \"activeDate\", \"selected\", \"dateFilter\", \"maxDate\", \"minDate\", \"activeDateChange\", \"monthSelected\", \"selectedChange\"], [3, \"activeDate\", \"selected\", \"dateFilter\", \"maxDate\", \"minDate\", \"activeDateChange\", \"yearSelected\", \"selectedChange\"]],\n    template: function NgxMatCalendar_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, NgxMatCalendar_ng_template_0_Template, 0, 0, \"ng-template\", 0);\n        ɵngcc0.ɵɵelementStart(1, \"div\", 1);\n        ɵngcc0.ɵɵtemplate(2, NgxMatCalendar_ngx_mat_month_view_2_Template, 1, 6, \"ngx-mat-month-view\", 2);\n        ɵngcc0.ɵɵtemplate(3, NgxMatCalendar_ngx_mat_year_view_3_Template, 1, 5, \"ngx-mat-year-view\", 3);\n        ɵngcc0.ɵɵtemplate(4, NgxMatCalendar_ngx_mat_multi_year_view_4_Template, 1, 5, \"ngx-mat-multi-year-view\", 4);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"cdkPortalOutlet\", ctx._calendarHeaderPortal);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngSwitch\", ctx.currentView);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngSwitchCase\", \"month\");\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngSwitchCase\", \"year\");\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngSwitchCase\", \"multi-year\");\n      }\n    },\n    directives: [ɵngcc5.CdkPortalOutlet, ɵngcc1.NgSwitch, ɵngcc1.NgSwitchCase, NgxMatMonthView, NgxMatYearView, NgxMatMultiYearView],\n    styles: [\".mat-calendar{display:block}.mat-calendar-header{padding:8px 8px 0}.mat-calendar-content{outline:none;padding:0 8px 8px}.mat-calendar-controls{display:flex;margin:5% calc(4.71429% - 16px)}.mat-calendar-spacer{flex:1 1 auto}.mat-calendar-period-button{min-width:0}.mat-calendar-arrow{border-left:5px solid transparent;border-right:5px solid transparent;border-top-style:solid;border-top-width:5px;display:inline-block;height:0;margin:0 0 0 5px;vertical-align:middle;width:0}.mat-calendar-arrow.mat-calendar-invert{transform:rotate(180deg)}[dir=rtl] .mat-calendar-arrow{margin:0 5px 0 0}.mat-calendar-next-button,.mat-calendar-previous-button{position:relative}.mat-calendar-next-button:after,.mat-calendar-previous-button:after{border:solid;border-width:2px 0 0;bottom:0;content:\\\"\\\";left:0;margin:15.5px;position:absolute;right:0;top:0}[dir=rtl] .mat-calendar-next-button,[dir=rtl] .mat-calendar-previous-button{transform:rotate(180deg)}.mat-calendar-previous-button:after{border-left-width:2px;transform:translateX(2px) rotate(-45deg)}.mat-calendar-next-button:after{border-right-width:2px;transform:translateX(-2px) rotate(45deg)}.mat-calendar-table{border-collapse:collapse;border-spacing:0;width:100%}.mat-calendar-table-header th{padding:0 0 8px;text-align:center}.mat-calendar-table-header-divider{height:1px;position:relative}.mat-calendar-table-header-divider:after{content:\\\"\\\";height:1px;left:-8px;position:absolute;right:-8px;top:0}\"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return NgxMatCalendar;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\r\n   * An input indicating the type of the header component, if set.\r\n   * @type {?}\r\n   */\n  NgxMatCalendar.prototype.headerComponent;\n  /**\r\n   * A portal containing the header component type for this calendar.\r\n   * @type {?}\r\n   */\n\n  NgxMatCalendar.prototype._calendarHeaderPortal;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatCalendar.prototype._intlChanges;\n  /**\r\n   * Used for scheduling that focus should be moved to the active cell on the next tick.\r\n   * We need to schedule it, rather than do it immediately, because we have to wait\r\n   * for Angular to re-evaluate the view children.\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatCalendar.prototype._moveFocusOnNextTick;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatCalendar.prototype._startAt;\n  /**\r\n   * Whether the calendar should be started in month or year view.\r\n   * @type {?}\r\n   */\n\n  NgxMatCalendar.prototype.startView;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatCalendar.prototype._selected;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatCalendar.prototype._minDate;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatCalendar.prototype._maxDate;\n  /**\r\n   * Function used to filter which dates are selectable.\r\n   * @type {?}\r\n   */\n\n  NgxMatCalendar.prototype.dateFilter;\n  /**\r\n   * Function that can be used to add custom CSS classes to dates.\r\n   * @type {?}\r\n   */\n\n  NgxMatCalendar.prototype.dateClass;\n  /**\r\n   * Emits when the currently selected date changes.\r\n   * @type {?}\r\n   */\n\n  NgxMatCalendar.prototype.selectedChange;\n  /**\r\n   * Emits the year chosen in multiyear view.\r\n   * This doesn't imply a change on the selected date.\r\n   * @type {?}\r\n   */\n\n  NgxMatCalendar.prototype.yearSelected;\n  /**\r\n   * Emits the month chosen in year view.\r\n   * This doesn't imply a change on the selected date.\r\n   * @type {?}\r\n   */\n\n  NgxMatCalendar.prototype.monthSelected;\n  /**\r\n   * Emits when any date is selected.\r\n   * @type {?}\r\n   */\n\n  NgxMatCalendar.prototype._userSelection;\n  /**\r\n   * Reference to the current month view component.\r\n   * @type {?}\r\n   */\n\n  NgxMatCalendar.prototype.monthView;\n  /**\r\n   * Reference to the current year view component.\r\n   * @type {?}\r\n   */\n\n  NgxMatCalendar.prototype.yearView;\n  /**\r\n   * Reference to the current multi-year view component.\r\n   * @type {?}\r\n   */\n\n  NgxMatCalendar.prototype.multiYearView;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatCalendar.prototype._clampedActiveDate;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatCalendar.prototype._currentView;\n  /**\r\n   * Emits whenever there is a state change that the header may need to respond to.\r\n   * @type {?}\r\n   */\n\n  NgxMatCalendar.prototype.stateChanges;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatCalendar.prototype._dateAdapter;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatCalendar.prototype._dateFormats;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatCalendar.prototype._changeDetectorRef;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: lib/timepicker.component.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @template D\r\n */\n\n\nlet NgxMatTimepickerComponent = /*#__PURE__*/(() => {\n  class NgxMatTimepickerComponent {\n    /**\r\n     * @param {?} _dateAdapter\r\n     * @param {?} cd\r\n     * @param {?} formBuilder\r\n     */\n    constructor(_dateAdapter, cd, formBuilder) {\n      this._dateAdapter = _dateAdapter;\n      this.cd = cd;\n      this.formBuilder = formBuilder;\n      this.disabled = false;\n      this.showSpinners = true;\n      this.stepHour = DEFAULT_STEP;\n      this.stepMinute = DEFAULT_STEP;\n      this.stepSecond = DEFAULT_STEP;\n      this.showSeconds = false;\n      this.disableMinute = false;\n      this.enableMeridian = false;\n      this.color = 'primary';\n      this.meridian = MERIDIANS.AM;\n\n      this._onChange =\n      /**\r\n      * @return {?}\r\n      */\n      () => {};\n\n      this._onTouched =\n      /**\r\n      * @return {?}\r\n      */\n      () => {};\n\n      this._destroyed = new Subject();\n      this.pattern = PATTERN_INPUT_HOUR;\n\n      if (!this._dateAdapter) {\n        throw createMissingDateImplError('NgxMatDateAdapter');\n      }\n\n      this.form = this.formBuilder.group({\n        hour: [{\n          value: null,\n          disabled: this.disabled\n        }, [Validators.required, Validators.pattern(PATTERN_INPUT_HOUR)]],\n        minute: [{\n          value: null,\n          disabled: this.disabled\n        }, [Validators.required, Validators.pattern(PATTERN_INPUT_MINUTE)]],\n        second: [{\n          value: null,\n          disabled: this.disabled\n        }, [Validators.required, Validators.pattern(PATTERN_INPUT_SECOND)]]\n      });\n    }\n    /**\r\n     * Hour\r\n     * @private\r\n     * @return {?}\r\n     */\n\n\n    get hour() {\n      /** @type {?} */\n      let val = Number(this.form.controls['hour'].value);\n      return isNaN(val) ? 0 : val;\n    }\n\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\n    get minute() {\n      /** @type {?} */\n      let val = Number(this.form.controls['minute'].value);\n      return isNaN(val) ? 0 : val;\n    }\n\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\n    get second() {\n      /** @type {?} */\n      let val = Number(this.form.controls['second'].value);\n      return isNaN(val) ? 0 : val;\n    }\n\n    /**\r\n     * Whether or not the form is valid\r\n     * @return {?}\r\n     */\n    get valid() {\n      return this.form.valid;\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    ngOnInit() {\n      this.form.valueChanges.pipe(takeUntil(this._destroyed), debounceTime(400)).subscribe(\n      /**\r\n      * @param {?} val\r\n      * @return {?}\r\n      */\n      val => {\n        this._updateModel();\n      });\n    }\n    /**\r\n     * @param {?} changes\r\n     * @return {?}\r\n     */\n\n\n    ngOnChanges(changes) {\n      if (changes.disabled || changes.disableMinute) {\n        this._setDisableStates();\n      }\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    ngOnDestroy() {\n      this._destroyed.next();\n\n      this._destroyed.complete();\n    }\n    /**\r\n     * Writes a new value to the element.\r\n     * @param {?} val\r\n     * @return {?}\r\n     */\n\n\n    writeValue(val) {\n      if (val != null) {\n        this._model = val;\n      } else {\n        this._model = this._dateAdapter.today();\n\n        if (this.defaultTime != null) {\n          this._dateAdapter.setTimeByDefaultValues(this._model, this.defaultTime);\n        }\n      }\n\n      this._updateHourMinuteSecond();\n    }\n    /**\r\n     * Registers a callback function that is called when the control's value changes in the UI.\r\n     * @param {?} fn\r\n     * @return {?}\r\n     */\n\n\n    registerOnChange(fn) {\n      this._onChange = fn;\n    }\n    /**\r\n     * Set the function to be called when the control receives a touch event.\r\n     * @param {?} fn\r\n     * @return {?}\r\n     */\n\n\n    registerOnTouched(fn) {\n      this._onTouched = fn;\n    }\n    /**\r\n     * Enables or disables the appropriate DOM element\r\n     * @param {?} isDisabled\r\n     * @return {?}\r\n     */\n\n\n    setDisabledState(isDisabled) {\n      this._disabled = isDisabled;\n      this.cd.markForCheck();\n    }\n    /**\r\n     * Format input\r\n     * @param {?} input\r\n     * @return {?}\r\n     */\n\n\n    formatInput(input) {\n      input.value = input.value.replace(NUMERIC_REGEX, '');\n    }\n    /**\r\n     * Toggle meridian\r\n     * @return {?}\r\n     */\n\n\n    toggleMeridian() {\n      this.meridian = this.meridian === MERIDIANS.AM ? MERIDIANS.PM : MERIDIANS.AM;\n      this.change('hour');\n    }\n    /**\r\n     * Change property of time\r\n     * @param {?} prop\r\n     * @param {?=} up\r\n     * @return {?}\r\n     */\n\n\n    change(prop, up) {\n      /** @type {?} */\n      const next = this._getNextValueByProp(prop, up);\n\n      this.form.controls[prop].setValue(formatTwoDigitTimeValue(next), {\n        onlySelf: false,\n        emitEvent: false\n      });\n\n      this._updateModel();\n    }\n    /**\r\n     * Update controls of form by model\r\n     * @private\r\n     * @return {?}\r\n     */\n\n\n    _updateHourMinuteSecond() {\n      /** @type {?} */\n      let _hour = this._dateAdapter.getHour(this._model);\n      /** @type {?} */\n\n\n      const _minute = this._dateAdapter.getMinute(this._model);\n      /** @type {?} */\n\n\n      const _second = this._dateAdapter.getSecond(this._model);\n\n      if (this.enableMeridian) {\n        if (_hour >= LIMIT_TIMES.meridian) {\n          _hour = _hour - LIMIT_TIMES.meridian;\n          this.meridian = MERIDIANS.PM;\n        } else {\n          this.meridian = MERIDIANS.AM;\n        }\n\n        if (_hour === 0) {\n          _hour = LIMIT_TIMES.meridian;\n        }\n      }\n\n      this.form.controls['hour'].setValue(formatTwoDigitTimeValue(_hour));\n      this.form.controls['minute'].setValue(formatTwoDigitTimeValue(_minute));\n      this.form.controls['second'].setValue(formatTwoDigitTimeValue(_second));\n    }\n    /**\r\n     * Update model\r\n     * @private\r\n     * @return {?}\r\n     */\n\n\n    _updateModel() {\n      /** @type {?} */\n      let _hour = this.hour;\n\n      if (this.enableMeridian) {\n        if (this.meridian === MERIDIANS.AM && _hour === LIMIT_TIMES.meridian) {\n          _hour = 0;\n        } else if (this.meridian === MERIDIANS.PM && _hour !== LIMIT_TIMES.meridian) {\n          _hour = _hour + LIMIT_TIMES.meridian;\n        }\n      }\n\n      this._dateAdapter.setHour(this._model, _hour);\n\n      this._dateAdapter.setMinute(this._model, this.minute);\n\n      this._dateAdapter.setSecond(this._model, this.second);\n\n      this._onChange(this._model);\n    }\n    /**\r\n     * Get next value by property\r\n     * @private\r\n     * @param {?} prop\r\n     * @param {?=} up\r\n     * @return {?}\r\n     */\n\n\n    _getNextValueByProp(prop, up) {\n      /** @type {?} */\n      const keyProp = prop[0].toUpperCase() + prop.slice(1);\n      /** @type {?} */\n\n      const min = LIMIT_TIMES[`min${keyProp}`];\n      /** @type {?} */\n\n      let max = LIMIT_TIMES[`max${keyProp}`];\n\n      if (prop === 'hour' && this.enableMeridian) {\n        max = LIMIT_TIMES.meridian;\n      }\n      /** @type {?} */\n\n\n      let next;\n\n      if (up == null) {\n        next = this[prop] % max;\n\n        if (prop === 'hour' && this.enableMeridian) {\n          if (next === 0) next = max;\n        }\n      } else {\n        next = up ? this[prop] + this[`step${keyProp}`] : this[prop] - this[`step${keyProp}`];\n\n        if (prop === 'hour' && this.enableMeridian) {\n          next = next % (max + 1);\n          if (next === 0) next = up ? 1 : max;\n        } else {\n          next = next % max;\n        }\n\n        if (up) {\n          next = next > max ? next - max + min : next;\n        } else {\n          next = next < min ? next - min + max : next;\n        }\n      }\n\n      return next;\n    }\n    /**\r\n     * Set disable states\r\n     * @private\r\n     * @return {?}\r\n     */\n\n\n    _setDisableStates() {\n      if (this.disabled) {\n        this.form.disable();\n      } else {\n        this.form.enable();\n\n        if (this.disableMinute) {\n          this.form.get('minute').disable();\n\n          if (this.showSeconds) {\n            this.form.get('second').disable();\n          }\n        }\n      }\n    }\n\n  }\n\n  NgxMatTimepickerComponent.ɵfac = function NgxMatTimepickerComponent_Factory(t) {\n    return new (t || NgxMatTimepickerComponent)(ɵngcc0.ɵɵdirectiveInject(NgxMatDateAdapter, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc6.FormBuilder));\n  };\n\n  NgxMatTimepickerComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: NgxMatTimepickerComponent,\n    selectors: [[\"ngx-mat-timepicker\"]],\n    hostAttrs: [1, \"ngx-mat-timepicker\"],\n    inputs: {\n      disabled: \"disabled\",\n      showSpinners: \"showSpinners\",\n      stepHour: \"stepHour\",\n      stepMinute: \"stepMinute\",\n      stepSecond: \"stepSecond\",\n      showSeconds: \"showSeconds\",\n      disableMinute: \"disableMinute\",\n      enableMeridian: \"enableMeridian\",\n      color: \"color\",\n      defaultTime: \"defaultTime\"\n    },\n    exportAs: [\"ngxMatTimepicker\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(\n      /**\n      * @return {?}\n      */\n      () => NgxMatTimepickerComponent),\n      multi: true\n    }]), ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 18,\n    vars: 7,\n    consts: [[3, \"formGroup\"], [1, \"ngx-mat-timepicker-table\"], [1, \"ngx-mat-timepicker-tbody\"], [4, \"ngIf\"], [\"appearance\", \"legacy\"], [\"type\", \"text\", \"matInput\", \"\", \"maxlength\", \"2\", \"formControlName\", \"hour\", 3, \"input\", \"keydown.ArrowUp\", \"keydown.ArrowDown\", \"blur\"], [1, \"ngx-mat-timepicker-spacer\"], [\"type\", \"text\", \"matInput\", \"\", \"maxlength\", \"2\", \"formControlName\", \"minute\", 3, \"input\", \"keydown.ArrowUp\", \"keydown.ArrowDown\", \"blur\"], [\"class\", \"ngx-mat-timepicker-spacer\", 4, \"ngIf\"], [\"class\", \"ngx-mat-timepicker-meridian\", 4, \"ngIf\"], [\"type\", \"button\", \"mat-icon-button\", \"\", \"aria-label\", \"expand_less icon\", 3, \"disabled\", \"click\"], [\"type\", \"text\", \"matInput\", \"\", \"maxlength\", \"2\", \"formControlName\", \"second\", 3, \"input\", \"keydown.ArrowUp\", \"keydown.ArrowDown\", \"blur\"], [1, \"ngx-mat-timepicker-meridian\"], [\"mat-button\", \"\", \"mat-stroked-button\", \"\", 3, \"color\", \"disabled\", \"click\"], [\"type\", \"button\", \"mat-icon-button\", \"\", \"aria-label\", \"expand_more icon\", 3, \"disabled\", \"click\"]],\n    template: function NgxMatTimepickerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"form\", 0);\n        ɵngcc0.ɵɵelementStart(1, \"table\", 1);\n        ɵngcc0.ɵɵelementStart(2, \"tbody\", 2);\n        ɵngcc0.ɵɵtemplate(3, NgxMatTimepickerComponent_tr_3_Template, 14, 5, \"tr\", 3);\n        ɵngcc0.ɵɵelementStart(4, \"tr\");\n        ɵngcc0.ɵɵelementStart(5, \"td\");\n        ɵngcc0.ɵɵelementStart(6, \"mat-form-field\", 4);\n        ɵngcc0.ɵɵelementStart(7, \"input\", 5);\n        ɵngcc0.ɵɵlistener(\"input\", function NgxMatTimepickerComponent_Template_input_input_7_listener($event) {\n          return ctx.formatInput($event.target);\n        })(\"keydown.ArrowUp\", function NgxMatTimepickerComponent_Template_input_keydown_ArrowUp_7_listener($event) {\n          ctx.change(\"hour\", true);\n          return $event.preventDefault();\n        })(\"keydown.ArrowDown\", function NgxMatTimepickerComponent_Template_input_keydown_ArrowDown_7_listener($event) {\n          ctx.change(\"hour\", false);\n          return $event.preventDefault();\n        })(\"blur\", function NgxMatTimepickerComponent_Template_input_blur_7_listener() {\n          return ctx.change(\"hour\");\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(8, \"td\", 6);\n        ɵngcc0.ɵɵtext(9, \":\");\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(10, \"td\");\n        ɵngcc0.ɵɵelementStart(11, \"mat-form-field\", 4);\n        ɵngcc0.ɵɵelementStart(12, \"input\", 7);\n        ɵngcc0.ɵɵlistener(\"input\", function NgxMatTimepickerComponent_Template_input_input_12_listener($event) {\n          return ctx.formatInput($event.target);\n        })(\"keydown.ArrowUp\", function NgxMatTimepickerComponent_Template_input_keydown_ArrowUp_12_listener($event) {\n          ctx.change(\"minute\", true);\n          return $event.preventDefault();\n        })(\"keydown.ArrowDown\", function NgxMatTimepickerComponent_Template_input_keydown_ArrowDown_12_listener($event) {\n          ctx.change(\"minute\", false);\n          return $event.preventDefault();\n        })(\"blur\", function NgxMatTimepickerComponent_Template_input_blur_12_listener() {\n          return ctx.change(\"minute\");\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtemplate(13, NgxMatTimepickerComponent_td_13_Template, 2, 0, \"td\", 8);\n        ɵngcc0.ɵɵtemplate(14, NgxMatTimepickerComponent_td_14_Template, 3, 0, \"td\", 3);\n        ɵngcc0.ɵɵtemplate(15, NgxMatTimepickerComponent_td_15_Template, 1, 0, \"td\", 8);\n        ɵngcc0.ɵɵtemplate(16, NgxMatTimepickerComponent_td_16_Template, 3, 3, \"td\", 9);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtemplate(17, NgxMatTimepickerComponent_tr_17_Template, 14, 6, \"tr\", 3);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"formGroup\", ctx.form);\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.showSpinners);\n        ɵngcc0.ɵɵadvance(10);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.showSeconds);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.showSeconds);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.enableMeridian);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.enableMeridian);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.showSpinners);\n      }\n    },\n    directives: [ɵngcc6.ɵNgNoValidate, ɵngcc6.NgControlStatusGroup, ɵngcc6.FormGroupDirective, ɵngcc1.NgIf, ɵngcc7.MatFormField, ɵngcc8.MatInput, ɵngcc6.DefaultValueAccessor, ɵngcc6.MaxLengthValidator, ɵngcc6.NgControlStatus, ɵngcc6.FormControlName, ɵngcc4.MatButton, ɵngcc9.MatIcon],\n    styles: [\".ngx-mat-timepicker{font-size:13px}.ngx-mat-timepicker form{min-width:90px}.ngx-mat-timepicker form .ngx-mat-timepicker-table .ngx-mat-timepicker-tbody tr td{text-align:center}.ngx-mat-timepicker form .ngx-mat-timepicker-table .ngx-mat-timepicker-tbody tr td.ngx-mat-timepicker-spacer{font-weight:700}.ngx-mat-timepicker form .ngx-mat-timepicker-table .ngx-mat-timepicker-tbody tr td.ngx-mat-timepicker-meridian .mat-button{border-radius:4px;border-radius:50%;flex-shrink:0;height:36px;line-height:36px;min-width:64px;min-width:0;padding:0;width:36px}.ngx-mat-timepicker form .ngx-mat-timepicker-table .ngx-mat-timepicker-tbody tr td .mat-icon-button{height:24px;line-height:24px;width:24px}.ngx-mat-timepicker form .ngx-mat-timepicker-table .ngx-mat-timepicker-tbody tr td .mat-icon-button .mat-icon{font-size:24px}.ngx-mat-timepicker form .ngx-mat-timepicker-table .ngx-mat-timepicker-tbody tr td .mat-form-field{max-width:20px;text-align:center;width:20px}\"],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return NgxMatTimepickerComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /** @type {?} */\n  NgxMatTimepickerComponent.prototype.form;\n  /** @type {?} */\n\n  NgxMatTimepickerComponent.prototype.disabled;\n  /** @type {?} */\n\n  NgxMatTimepickerComponent.prototype.showSpinners;\n  /** @type {?} */\n\n  NgxMatTimepickerComponent.prototype.stepHour;\n  /** @type {?} */\n\n  NgxMatTimepickerComponent.prototype.stepMinute;\n  /** @type {?} */\n\n  NgxMatTimepickerComponent.prototype.stepSecond;\n  /** @type {?} */\n\n  NgxMatTimepickerComponent.prototype.showSeconds;\n  /** @type {?} */\n\n  NgxMatTimepickerComponent.prototype.disableMinute;\n  /** @type {?} */\n\n  NgxMatTimepickerComponent.prototype.enableMeridian;\n  /** @type {?} */\n\n  NgxMatTimepickerComponent.prototype.defaultTime;\n  /** @type {?} */\n\n  NgxMatTimepickerComponent.prototype.color;\n  /** @type {?} */\n\n  NgxMatTimepickerComponent.prototype.meridian;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatTimepickerComponent.prototype._onChange;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatTimepickerComponent.prototype._onTouched;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatTimepickerComponent.prototype._disabled;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatTimepickerComponent.prototype._model;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatTimepickerComponent.prototype._destroyed;\n  /** @type {?} */\n\n  NgxMatTimepickerComponent.prototype.pattern;\n  /** @type {?} */\n\n  NgxMatTimepickerComponent.prototype._dateAdapter;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatTimepickerComponent.prototype.cd;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatTimepickerComponent.prototype.formBuilder;\n  /* Skipping unhandled member: ;*/\n\n  /* Skipping unhandled member: ;*/\n\n  /* Skipping unhandled member: ;*/\n}\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: lib/datetime-picker.component.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * Used to generate a unique ID for each datepicker instance.\r\n * @type {?}\r\n */\n\n\nlet datepickerUid = 0; // Boilerplate for applying mixins to MatDatepickerContent.\n\n/**\r\n * \\@docs-private\r\n */\n\nclass MatDatepickerContentBase {\n  /**\r\n   * @param {?} _elementRef\r\n   */\n  constructor(_elementRef) {\n    this._elementRef = _elementRef;\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  MatDatepickerContentBase.prototype._elementRef;\n}\n/** @type {?} */\n\n\nconst _MatDatepickerContentMixinBase = mixinColor(MatDatepickerContentBase);\n/**\r\n * Component used as the content for the datepicker dialog and popup. We use this instead of using\r\n * NgxMatCalendar directly as the content so we can control the initial focus. This also gives us a\r\n * place to put additional features of the popup that are not part of the calendar itself in the\r\n * future. (e.g. confirmation buttons).\r\n * \\@docs-private\r\n * @template D\r\n */\n\n\nlet NgxMatDatetimeContent = /*#__PURE__*/(() => {\n  class NgxMatDatetimeContent extends _MatDatepickerContentMixinBase {\n    /**\r\n     * @param {?} elementRef\r\n     * @param {?} cd\r\n     * @param {?} _viewContainerRef\r\n     */\n    constructor(elementRef, cd, _viewContainerRef) {\n      super(elementRef);\n      this.cd = cd;\n      this._viewContainerRef = _viewContainerRef;\n    }\n    /**\r\n     * Whether or not the selected date is valid (min,max...)\r\n     * @return {?}\r\n     */\n\n\n    get valid() {\n      if (this.datepicker.hideTime) return this.datepicker.valid;\n      return this._timePicker && this._timePicker.valid && this.datepicker.valid;\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    get isViewMonth() {\n      if (!this._calendar || this._calendar.currentView == null) return true;\n      return this._calendar.currentView == 'month';\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    ngAfterViewInit() {\n      this._calendar.focusActiveCell();\n\n      if (this.datepicker._customIcon) {\n        this._templateCustomIconPortal = new TemplatePortal(this.datepicker._customIcon, this._viewContainerRef);\n        this.cd.detectChanges();\n      }\n    }\n\n  }\n\n  NgxMatDatetimeContent.ɵfac = function NgxMatDatetimeContent_Factory(t) {\n    return new (t || NgxMatDatetimeContent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  NgxMatDatetimeContent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: NgxMatDatetimeContent,\n    selectors: [[\"ngx-mat-datetime-content\"]],\n    viewQuery: function NgxMatDatetimeContent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(NgxMatCalendar, 5);\n        ɵngcc0.ɵɵviewQuery(NgxMatTimepickerComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._calendar = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._timePicker = _t.first);\n      }\n    },\n    hostAttrs: [1, \"mat-datepicker-content\"],\n    hostVars: 3,\n    hostBindings: function NgxMatDatetimeContent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵsyntheticHostProperty(\"@transformPanel\", \"enter\");\n        ɵngcc0.ɵɵclassProp(\"mat-datepicker-content-touch\", ctx.datepicker.touchUi);\n      }\n    },\n    inputs: {\n      color: \"color\"\n    },\n    exportAs: [\"ngxMatDatetimeContent\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    decls: 2,\n    vars: 12,\n    consts: [[\"cdkTrapFocus\", \"\", 3, \"id\", \"ngClass\", \"startAt\", \"startView\", \"minDate\", \"maxDate\", \"dateFilter\", \"headerComponent\", \"selected\", \"dateClass\", \"selectedChange\", \"yearSelected\", \"monthSelected\"], [4, \"ngIf\"], [\"class\", \"time-container\", 3, \"disable-seconds\", 4, \"ngIf\"], [1, \"actions\"], [\"mat-button\", \"\", \"mat-stroked-button\", \"\", \"cdkFocusInitial\", \"\", 3, \"color\", \"disabled\", \"click\"], [3, \"cdkPortalOutlet\"], [1, \"time-container\"], [3, \"showSpinners\", \"showSeconds\", \"disabled\", \"stepHour\", \"stepMinute\", \"stepSecond\", \"ngModel\", \"color\", \"enableMeridian\", \"disableMinute\", \"ngModelChange\"]],\n    template: function NgxMatDatetimeContent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"ngx-mat-calendar\", 0);\n        ɵngcc0.ɵɵlistener(\"selectedChange\", function NgxMatDatetimeContent_Template_ngx_mat_calendar_selectedChange_0_listener($event) {\n          return ctx.datepicker.select($event);\n        })(\"yearSelected\", function NgxMatDatetimeContent_Template_ngx_mat_calendar_yearSelected_0_listener($event) {\n          return ctx.datepicker._selectYear($event);\n        })(\"monthSelected\", function NgxMatDatetimeContent_Template_ngx_mat_calendar_monthSelected_0_listener($event) {\n          return ctx.datepicker._selectMonth($event);\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtemplate(1, NgxMatDatetimeContent_ng_container_1_Template, 6, 5, \"ng-container\", 1);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"id\", ctx.datepicker.id)(\"ngClass\", ctx.datepicker.panelClass)(\"startAt\", ctx.datepicker.startAt)(\"startView\", ctx.datepicker.startView)(\"minDate\", ctx.datepicker._minDate)(\"maxDate\", ctx.datepicker._maxDate)(\"dateFilter\", ctx.datepicker._dateFilter)(\"headerComponent\", ctx.datepicker.calendarHeaderComponent)(\"selected\", ctx.datepicker._selected)(\"dateClass\", ctx.datepicker.dateClass)(\"@fadeInCalendar\", \"enter\");\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.isViewMonth);\n      }\n    },\n    directives: [NgxMatCalendar, ɵngcc1.NgClass, ɵngcc1.NgIf, ɵngcc4.MatButton, ɵngcc5.CdkPortalOutlet, NgxMatTimepickerComponent, ɵngcc6.NgControlStatus, ɵngcc6.NgModel, ɵngcc9.MatIcon],\n    styles: [\".mat-datepicker-content{border-radius:4px;box-shadow:0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12);display:block}.mat-datepicker-content .mat-calendar{width:296px}.mat-datepicker-content .time-container{display:flex;justify-content:center;padding-top:5px;position:relative}.mat-datepicker-content .time-container.disable-seconds .ngx-mat-timepicker .table{margin-left:9px}.mat-datepicker-content .time-container:before{background-color:rgba(0,0,0,.12);content:\\\"\\\";height:1px;left:0;position:absolute;right:0;top:0}.mat-datepicker-content .actions{display:flex;justify-content:flex-end;padding:5px 15px 10px}\"],\n    encapsulation: 2,\n    data: {\n      animation: [matDatepickerAnimations.transformPanel, matDatepickerAnimations.fadeInCalendar]\n    },\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return NgxMatDatetimeContent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\r\n   * Reference to the internal calendar component.\r\n   * @type {?}\r\n   */\n  NgxMatDatetimeContent.prototype._calendar;\n  /**\r\n   * Reference to the internal time picker component.\r\n   * @type {?}\r\n   */\n\n  NgxMatDatetimeContent.prototype._timePicker;\n  /**\r\n   * Reference to the datepicker that created the overlay.\r\n   * @type {?}\r\n   */\n\n  NgxMatDatetimeContent.prototype.datepicker;\n  /**\r\n   * Whether the datepicker is above or below the input.\r\n   * @type {?}\r\n   */\n\n  NgxMatDatetimeContent.prototype._isAbove;\n  /** @type {?} */\n\n  NgxMatDatetimeContent.prototype._templateCustomIconPortal;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimeContent.prototype.cd;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimeContent.prototype._viewContainerRef;\n} // TODO(mmalerba): We use a component instead of a directive here so the user can use implicit\n// template reference variables (e.g. #d vs #d=\"matDatepicker\"). We can change this to a directive\n// if angular adds support for `exportAs: '$implicit'` on directives.\n\n/**\r\n * Component responsible for managing the datepicker popup/dialog.\r\n * @template D\r\n */\n\n\nlet NgxMatDatetimePicker = /*#__PURE__*/(() => {\n  class NgxMatDatetimePicker {\n    /**\r\n     * @param {?} _dialog\r\n     * @param {?} _overlay\r\n     * @param {?} _ngZone\r\n     * @param {?} _viewContainerRef\r\n     * @param {?} scrollStrategy\r\n     * @param {?} _dateAdapter\r\n     * @param {?} _dir\r\n     * @param {?} _document\r\n     */\n    constructor(_dialog, _overlay, _ngZone, _viewContainerRef, scrollStrategy, _dateAdapter, _dir, _document) {\n      this._dialog = _dialog;\n      this._overlay = _overlay;\n      this._ngZone = _ngZone;\n      this._viewContainerRef = _viewContainerRef;\n      this._dateAdapter = _dateAdapter;\n      this._dir = _dir;\n      this._document = _document;\n      /**\r\n       * The view that the calendar should start in.\r\n       */\n\n      this.startView = 'month';\n      this._defaultColor = 'primary';\n      this._touchUi = false;\n      this._hideTime = false;\n      /**\r\n       * Emits selected year in multiyear view.\r\n       * This doesn't imply a change on the selected date.\r\n       */\n\n      this.yearSelected = new EventEmitter();\n      /**\r\n       * Emits selected month in year view.\r\n       * This doesn't imply a change on the selected date.\r\n       */\n\n      this.monthSelected = new EventEmitter();\n      /**\r\n       * Emits when the datepicker has been opened.\r\n       */\n\n      this.openedStream = new EventEmitter();\n      /**\r\n       * Emits when the datepicker has been closed.\r\n       */\n\n      this.closedStream = new EventEmitter();\n      this._opened = false;\n      this._showSpinners = true;\n      this._showSeconds = false;\n      this._stepHour = DEFAULT_STEP;\n      this._stepMinute = DEFAULT_STEP;\n      this._stepSecond = DEFAULT_STEP;\n      this._enableMeridian = false;\n      this._hasBackdrop = true;\n      /**\r\n       * The id for the datepicker calendar.\r\n       */\n\n      this.id = `mat-datepicker-${datepickerUid++}`;\n      this._validSelected = null;\n      /**\r\n       * The element that was focused before the datepicker was opened.\r\n       */\n\n      this._focusedElementBeforeOpen = null;\n      /**\r\n       * Subscription to value changes in the associated input element.\r\n       */\n\n      this._inputSubscription = Subscription.EMPTY;\n      /**\r\n       * Emits when the datepicker is disabled.\r\n       */\n\n      this.stateChanges = new Subject();\n      /**\r\n       * Emits new selected date when selected date changes.\r\n       */\n\n      this._selectedChanged = new Subject();\n      /**\r\n       * The form control validator for the min date.\r\n       */\n\n      this._minValidator =\n      /**\r\n      * @return {?}\r\n      */\n      () => {\n        return !this._minDate || !this._selected || this._dateAdapter.compareDateWithTime(this._minDate, this._selected, this.showSeconds) <= 0 ? null : {\n          'matDatetimePickerMin': {\n            'min': this._minDate,\n            'actual': this._selected\n          }\n        };\n      };\n      /**\r\n       * The form control validator for the max date.\r\n       */\n\n\n      this._maxValidator =\n      /**\r\n      * @return {?}\r\n      */\n      () => {\n        return !this._maxDate || !this._selected || this._dateAdapter.compareDateWithTime(this._maxDate, this._selected, this.showSeconds) >= 0 ? null : {\n          'matDatetimePickerMax': {\n            'max': this._maxDate,\n            'actual': this._selected\n          }\n        };\n      };\n\n      if (!this._dateAdapter) {\n        throw createMissingDateImplError('NgxMatDateAdapter');\n      }\n\n      this._scrollStrategy = scrollStrategy;\n    }\n    /**\r\n     * The date to open the calendar to initially.\r\n     * @return {?}\r\n     */\n\n\n    get startAt() {\n      // If an explicit startAt is set we start there, otherwise we start at whatever the currently\n      // selected value is.\n      return this._startAt || (this.datepickerInput ? this.datepickerInput.value : null);\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set startAt(value) {\n      this._startAt = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n    /**\r\n     * Default Color palette to use on the datepicker's calendar.\r\n     * @return {?}\r\n     */\n\n\n    get defaultColor() {\n      return this._defaultColor;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set defaultColor(value) {\n      this._defaultColor = value;\n    }\n    /**\r\n     * Color palette to use on the datepicker's calendar.\r\n     * @return {?}\r\n     */\n\n\n    get color() {\n      return this._color || (this.datepickerInput ? this.datepickerInput._getThemePalette() : 'primary');\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set color(value) {\n      this._color = value;\n    }\n    /**\r\n     * Whether the calendar UI is in touch mode. In touch mode the calendar opens in a dialog rather\r\n     * than a popup and elements have more padding to allow for bigger touch targets.\r\n     * @return {?}\r\n     */\n\n\n    get touchUi() {\n      return this._touchUi;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set touchUi(value) {\n      this._touchUi = coerceBooleanProperty(value);\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    get hideTime() {\n      return this._hideTime;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set hideTime(value) {\n      this._hideTime = coerceBooleanProperty(value);\n    }\n    /**\r\n     * Whether the datepicker pop-up should be disabled.\r\n     * @return {?}\r\n     */\n\n\n    get disabled() {\n      return this._disabled === undefined && this.datepickerInput ? this.datepickerInput.disabled : !!this._disabled;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set disabled(value) {\n      /** @type {?} */\n      const newValue = coerceBooleanProperty(value);\n\n      if (newValue !== this._disabled) {\n        this._disabled = newValue;\n        this.stateChanges.next(newValue);\n      }\n    }\n    /**\r\n     * Whether the calendar is open.\r\n     * @return {?}\r\n     */\n\n\n    get opened() {\n      return this._opened;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set opened(value) {\n      value ? this.open() : this.close();\n    }\n    /**\r\n     * Whether the timepicker'spinners is shown.\r\n     * @return {?}\r\n     */\n\n\n    get showSpinners() {\n      return this._showSpinners;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set showSpinners(value) {\n      this._showSpinners = value;\n    }\n    /**\r\n     * Whether the second part is disabled.\r\n     * @return {?}\r\n     */\n\n\n    get showSeconds() {\n      return this._showSeconds;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set showSeconds(value) {\n      this._showSeconds = value;\n    }\n    /**\r\n     * Step hour\r\n     * @return {?}\r\n     */\n\n\n    get stepHour() {\n      return this._stepHour;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set stepHour(value) {\n      this._stepHour = value;\n    }\n    /**\r\n     * Step minute\r\n     * @return {?}\r\n     */\n\n\n    get stepMinute() {\n      return this._stepMinute;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set stepMinute(value) {\n      this._stepMinute = value;\n    }\n    /**\r\n     * Step second\r\n     * @return {?}\r\n     */\n\n\n    get stepSecond() {\n      return this._stepSecond;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set stepSecond(value) {\n      this._stepSecond = value;\n    }\n    /**\r\n     * Enable meridian\r\n     * @return {?}\r\n     */\n\n\n    get enableMeridian() {\n      return this._enableMeridian;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set enableMeridian(value) {\n      this._enableMeridian = value;\n    }\n    /**\r\n     * disable minute\r\n     * @return {?}\r\n     */\n\n\n    get disableMinute() {\n      return this._disableMinute;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set disableMinute(value) {\n      this._disableMinute = value;\n    }\n    /**\r\n     * Step second\r\n     * @return {?}\r\n     */\n\n\n    get defaultTime() {\n      return this._defaultTime;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set defaultTime(value) {\n      this._defaultTime = value;\n    }\n    /**\r\n     * The currently selected date.\r\n     * @return {?}\r\n     */\n\n\n    get _selected() {\n      return this._validSelected;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set _selected(value) {\n      this._validSelected = value;\n    }\n    /**\r\n     * The minimum selectable date.\r\n     * @return {?}\r\n     */\n\n\n    get _minDate() {\n      return this.datepickerInput && this.datepickerInput.min;\n    }\n    /**\r\n     * The maximum selectable date.\r\n     * @return {?}\r\n     */\n\n\n    get _maxDate() {\n      return this.datepickerInput && this.datepickerInput.max;\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    get valid() {\n      /** @type {?} */\n      const minValidators = this._minValidator();\n      /** @type {?} */\n\n\n      const maxValidators = this._maxValidator();\n\n      return minValidators == null && maxValidators == null;\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    get _dateFilter() {\n      return this.datepickerInput && this.datepickerInput._dateFilter;\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    ngOnDestroy() {\n      this.close();\n\n      if (this._popupRef) {\n        this._popupRef.dispose();\n\n        this._popupComponentRef = null;\n      }\n\n      this._inputSubscription.unsubscribe();\n\n      this.stateChanges.complete();\n    }\n    /**\r\n     * Selects the given date\r\n     * @param {?} date\r\n     * @return {?}\r\n     */\n\n\n    select(date) {\n      this._dateAdapter.copyTime(date, this._selected);\n\n      this._selected = date;\n    }\n    /**\r\n     * Emits the selected year in multiyear view\r\n     * @param {?} normalizedYear\r\n     * @return {?}\r\n     */\n\n\n    _selectYear(normalizedYear) {\n      this.yearSelected.emit(normalizedYear);\n    }\n    /**\r\n     * Emits selected month in year view\r\n     * @param {?} normalizedMonth\r\n     * @return {?}\r\n     */\n\n\n    _selectMonth(normalizedMonth) {\n      this.monthSelected.emit(normalizedMonth);\n    }\n    /**\r\n     * OK button handler and close\r\n     * @return {?}\r\n     */\n\n\n    ok() {\n      /** @type {?} */\n      const cloned = this._dateAdapter.clone(this._selected);\n\n      this._selectedChanged.next(cloned);\n\n      this.close();\n    }\n    /**\r\n     * Cancel and close\r\n     * @return {?}\r\n     */\n\n\n    cancel() {\n      this._selected = this._rawValue;\n      this.close();\n    }\n    /**\r\n     * Register an input with this datepicker.\r\n     * @param {?} input The datepicker input to register with this datepicker.\r\n     * @return {?}\r\n     */\n\n\n    _registerInput(input) {\n      if (this.datepickerInput) {\n        throw Error('A NgxMatDatepicker can only be associated with a single input.');\n      }\n\n      this.datepickerInput = input;\n      this._inputSubscription = this.datepickerInput._valueChange.subscribe(\n      /**\r\n      * @param {?} value\r\n      * @return {?}\r\n      */\n      value => this._selected = value);\n    }\n    /**\r\n     * Open the calendar.\r\n     * @return {?}\r\n     */\n\n\n    open() {\n      this._rawValue = this._selected != null ? this._dateAdapter.clone(this._selected) : null;\n\n      if (this._selected == null) {\n        this._selected = this._dateAdapter.today();\n\n        if (this.defaultTime != null) {\n          this._dateAdapter.setTimeByDefaultValues(this._selected, this.defaultTime);\n        }\n      }\n\n      if (this._opened || this.disabled) {\n        return;\n      }\n\n      if (!this.datepickerInput) {\n        throw Error('Attempted to open an NgxMatDatepicker with no associated input.');\n      }\n\n      if (this._document) {\n        this._focusedElementBeforeOpen = this._document.activeElement;\n      }\n\n      this.touchUi ? this._openAsDialog() : this._openAsPopup();\n      this._opened = true;\n      this.openedStream.emit();\n    }\n    /**\r\n     * Close the calendar.\r\n     * @return {?}\r\n     */\n\n\n    close() {\n      if (!this._opened) {\n        return;\n      }\n\n      if (this._popupRef && this._popupRef.hasAttached()) {\n        this._popupRef.detach();\n      }\n\n      if (this._dialogRef) {\n        this._dialogRef.close();\n\n        this._dialogRef = null;\n      }\n\n      if (this._calendarPortal && this._calendarPortal.isAttached) {\n        this._calendarPortal.detach();\n      }\n      /** @type {?} */\n\n\n      const completeClose =\n      /**\r\n      * @return {?}\r\n      */\n      () => {\n        // The `_opened` could've been reset already if\n        // we got two events in quick succession.\n        if (this._opened) {\n          this._opened = false;\n          this.closedStream.emit();\n          this._focusedElementBeforeOpen = null;\n        }\n      };\n\n      if (this._focusedElementBeforeOpen && typeof this._focusedElementBeforeOpen.focus === 'function') {\n        // Because IE moves focus asynchronously, we can't count on it being restored before we've\n        // marked the datepicker as closed. If the event fires out of sequence and the element that\n        // we're refocusing opens the datepicker on focus, the user could be stuck with not being\n        // able to close the calendar at all. We work around it by making the logic, that marks\n        // the datepicker as closed, async as well.\n        this._focusedElementBeforeOpen.focus();\n\n        setTimeout(completeClose);\n      } else {\n        completeClose();\n      }\n    }\n    /**\r\n     * Open the calendar as a dialog.\r\n     * @private\r\n     * @return {?}\r\n     */\n\n\n    _openAsDialog() {\n      // Usually this would be handled by `open` which ensures that we can only have one overlay\n      // open at a time, however since we reset the variables in async handlers some overlays\n      // may slip through if the user opens and closes multiple times in quick succession (e.g.\n      // by holding down the enter key).\n      if (this._dialogRef) {\n        this._dialogRef.close();\n      }\n\n      this._dialogRef = this._dialog.open(NgxMatDatetimeContent, {\n        direction: this._dir ? this._dir.value : 'ltr',\n        viewContainerRef: this._viewContainerRef,\n        panelClass: 'mat-datepicker-dialog',\n        hasBackdrop: this._hasBackdrop\n      });\n\n      this._dialogRef.afterClosed().subscribe(\n      /**\r\n      * @return {?}\r\n      */\n      () => this.close());\n\n      this._dialogRef.componentInstance.datepicker = this;\n\n      this._setColor();\n    }\n    /**\r\n     * Open the calendar as a popup.\r\n     * @private\r\n     * @return {?}\r\n     */\n\n\n    _openAsPopup() {\n      if (!this._calendarPortal) {\n        this._calendarPortal = new ComponentPortal(NgxMatDatetimeContent, this._viewContainerRef);\n      }\n\n      if (!this._popupRef) {\n        this._createPopup();\n      }\n\n      if (!this._popupRef.hasAttached()) {\n        this._popupComponentRef = this._popupRef.attach(this._calendarPortal);\n        this._popupComponentRef.instance.datepicker = this;\n\n        this._setColor(); // Update the position once the calendar has rendered.\n\n\n        this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(\n        /**\r\n        * @return {?}\r\n        */\n        () => {\n          this._popupRef.updatePosition();\n        });\n      }\n    }\n    /**\r\n     * Create the popup.\r\n     * @private\r\n     * @return {?}\r\n     */\n\n\n    _createPopup() {\n      /** @type {?} */\n      const overlayConfig = new OverlayConfig({\n        positionStrategy: this._createPopupPositionStrategy(),\n        hasBackdrop: this._hasBackdrop,\n        backdropClass: 'mat-overlay-transparent-backdrop',\n        direction: this._dir,\n        scrollStrategy: this._scrollStrategy(),\n        panelClass: 'mat-datepicker-popup'\n      });\n      this._popupRef = this._overlay.create(overlayConfig);\n\n      this._popupRef.overlayElement.setAttribute('role', 'dialog');\n\n      merge(this._popupRef.backdropClick(), this._popupRef.detachments(), this._popupRef.keydownEvents().pipe(filter(\n      /**\r\n      * @param {?} event\r\n      * @return {?}\r\n      */\n      event => {\n        // Closing on alt + up is only valid when there's an input associated with the datepicker.\n        return event.keyCode === ESCAPE || this.datepickerInput && event.altKey && event.keyCode === UP_ARROW;\n      }))).subscribe(\n      /**\r\n      * @param {?} event\r\n      * @return {?}\r\n      */\n      event => {\n        if (event) {\n          event.preventDefault();\n        }\n\n        this._hasBackdrop && event ? this.cancel() : this.close();\n      });\n    }\n    /**\r\n     * Create the popup PositionStrategy.\r\n     * @private\r\n     * @return {?}\r\n     */\n\n\n    _createPopupPositionStrategy() {\n      return this._overlay.position().flexibleConnectedTo(this.datepickerInput.getConnectedOverlayOrigin()).withTransformOriginOn('.mat-datepicker-content').withFlexibleDimensions(false).withViewportMargin(8).withLockedPosition().withPositions([{\n        originX: 'start',\n        originY: 'bottom',\n        overlayX: 'start',\n        overlayY: 'top'\n      }, {\n        originX: 'start',\n        originY: 'top',\n        overlayX: 'start',\n        overlayY: 'bottom'\n      }, {\n        originX: 'end',\n        originY: 'bottom',\n        overlayX: 'end',\n        overlayY: 'top'\n      }, {\n        originX: 'end',\n        originY: 'top',\n        overlayX: 'end',\n        overlayY: 'bottom'\n      }]);\n    }\n    /**\r\n     * @private\r\n     * @param {?} obj The object to check.\r\n     * @return {?} The given object if it is both a date instance and valid, otherwise null.\r\n     */\n\n\n    _getValidDateOrNull(obj) {\n      return this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj) ? obj : null;\n    }\n    /**\r\n     * Passes the current theme color along to the calendar overlay.\r\n     * @private\r\n     * @return {?}\r\n     */\n\n\n    _setColor() {\n      /** @type {?} */\n      const color = this.color;\n\n      if (this._popupComponentRef) {\n        this._popupComponentRef.instance.color = color;\n      }\n\n      if (this._dialogRef) {\n        this._dialogRef.componentInstance.color = color;\n      }\n    }\n\n  }\n\n  NgxMatDatetimePicker.ɵfac = function NgxMatDatetimePicker_Factory(t) {\n    return new (t || NgxMatDatetimePicker)(ɵngcc0.ɵɵdirectiveInject(ɵngcc10.MatDialog), ɵngcc0.ɵɵdirectiveInject(ɵngcc11.Overlay), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(MAT_DATEPICKER_SCROLL_STRATEGY), ɵngcc0.ɵɵdirectiveInject(NgxMatDateAdapter, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Directionality, 8), ɵngcc0.ɵɵdirectiveInject(DOCUMENT, 8));\n  };\n\n  NgxMatDatetimePicker.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: NgxMatDatetimePicker,\n    selectors: [[\"ngx-mat-datetime-picker\"]],\n    contentQueries: function NgxMatDatetimePicker_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, TemplateRef, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._customIcon = _t.first);\n      }\n    },\n    inputs: {\n      startView: \"startView\",\n      startAt: \"startAt\",\n      defaultColor: \"defaultColor\",\n      color: \"color\",\n      touchUi: \"touchUi\",\n      hideTime: \"hideTime\",\n      disabled: \"disabled\",\n      opened: \"opened\",\n      showSpinners: \"showSpinners\",\n      showSeconds: \"showSeconds\",\n      stepHour: \"stepHour\",\n      stepMinute: \"stepMinute\",\n      stepSecond: \"stepSecond\",\n      enableMeridian: \"enableMeridian\",\n      disableMinute: \"disableMinute\",\n      defaultTime: \"defaultTime\",\n      calendarHeaderComponent: \"calendarHeaderComponent\",\n      panelClass: \"panelClass\",\n      dateClass: \"dateClass\"\n    },\n    outputs: {\n      yearSelected: \"yearSelected\",\n      monthSelected: \"monthSelected\",\n      openedStream: \"opened\",\n      closedStream: \"closed\"\n    },\n    exportAs: [\"ngxMatDatetimePicker\"],\n    decls: 0,\n    vars: 0,\n    template: function NgxMatDatetimePicker_Template(rf, ctx) {},\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return NgxMatDatetimePicker;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n  NgxMatDatetimePicker.prototype._scrollStrategy;\n  /**\r\n   * An input indicating the type of the custom header component for the calendar, if set.\r\n   * @type {?}\r\n   */\n\n  NgxMatDatetimePicker.prototype.calendarHeaderComponent;\n  /**\r\n   * Custom icon set by the consumer.\r\n   * @type {?}\r\n   */\n\n  NgxMatDatetimePicker.prototype._customIcon;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimePicker.prototype._startAt;\n  /**\r\n   * The view that the calendar should start in.\r\n   * @type {?}\r\n   */\n\n  NgxMatDatetimePicker.prototype.startView;\n  /** @type {?} */\n\n  NgxMatDatetimePicker.prototype._defaultColor;\n  /** @type {?} */\n\n  NgxMatDatetimePicker.prototype._color;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimePicker.prototype._touchUi;\n  /** @type {?} */\n\n  NgxMatDatetimePicker.prototype._hideTime;\n  /** @type {?} */\n\n  NgxMatDatetimePicker.prototype._disabled;\n  /**\r\n   * Emits selected year in multiyear view.\r\n   * This doesn't imply a change on the selected date.\r\n   * @type {?}\r\n   */\n\n  NgxMatDatetimePicker.prototype.yearSelected;\n  /**\r\n   * Emits selected month in year view.\r\n   * This doesn't imply a change on the selected date.\r\n   * @type {?}\r\n   */\n\n  NgxMatDatetimePicker.prototype.monthSelected;\n  /**\r\n   * Classes to be passed to the date picker panel. Supports the same syntax as `ngClass`.\r\n   * @type {?}\r\n   */\n\n  NgxMatDatetimePicker.prototype.panelClass;\n  /**\r\n   * Function that can be used to add custom CSS classes to dates.\r\n   * @type {?}\r\n   */\n\n  NgxMatDatetimePicker.prototype.dateClass;\n  /**\r\n   * Emits when the datepicker has been opened.\r\n   * @type {?}\r\n   */\n\n  NgxMatDatetimePicker.prototype.openedStream;\n  /**\r\n   * Emits when the datepicker has been closed.\r\n   * @type {?}\r\n   */\n\n  NgxMatDatetimePicker.prototype.closedStream;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimePicker.prototype._opened;\n  /** @type {?} */\n\n  NgxMatDatetimePicker.prototype._showSpinners;\n  /** @type {?} */\n\n  NgxMatDatetimePicker.prototype._showSeconds;\n  /** @type {?} */\n\n  NgxMatDatetimePicker.prototype._stepHour;\n  /** @type {?} */\n\n  NgxMatDatetimePicker.prototype._stepMinute;\n  /** @type {?} */\n\n  NgxMatDatetimePicker.prototype._stepSecond;\n  /** @type {?} */\n\n  NgxMatDatetimePicker.prototype._enableMeridian;\n  /** @type {?} */\n\n  NgxMatDatetimePicker.prototype._disableMinute;\n  /** @type {?} */\n\n  NgxMatDatetimePicker.prototype._defaultTime;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimePicker.prototype._hasBackdrop;\n  /**\r\n   * The id for the datepicker calendar.\r\n   * @type {?}\r\n   */\n\n  NgxMatDatetimePicker.prototype.id;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimePicker.prototype._validSelected;\n  /**\r\n   * A reference to the overlay when the calendar is opened as a popup.\r\n   * @type {?}\r\n   */\n\n  NgxMatDatetimePicker.prototype._popupRef;\n  /**\r\n   * A reference to the dialog when the calendar is opened as a dialog.\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimePicker.prototype._dialogRef;\n  /**\r\n   * A portal containing the calendar for this datepicker.\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimePicker.prototype._calendarPortal;\n  /**\r\n   * Reference to the component instantiated in popup mode.\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimePicker.prototype._popupComponentRef;\n  /**\r\n   * The element that was focused before the datepicker was opened.\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimePicker.prototype._focusedElementBeforeOpen;\n  /**\r\n   * Subscription to value changes in the associated input element.\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimePicker.prototype._inputSubscription;\n  /**\r\n   * The input element this datepicker is associated with.\r\n   * @type {?}\r\n   */\n\n  NgxMatDatetimePicker.prototype.datepickerInput;\n  /**\r\n   * Emits when the datepicker is disabled.\r\n   * @type {?}\r\n   */\n\n  NgxMatDatetimePicker.prototype.stateChanges;\n  /**\r\n   * Emits new selected date when selected date changes.\r\n   * @type {?}\r\n   */\n\n  NgxMatDatetimePicker.prototype._selectedChanged;\n  /**\r\n   * Raw value before\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimePicker.prototype._rawValue;\n  /**\r\n   * The form control validator for the min date.\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimePicker.prototype._minValidator;\n  /**\r\n   * The form control validator for the max date.\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimePicker.prototype._maxValidator;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimePicker.prototype._dialog;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimePicker.prototype._overlay;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimePicker.prototype._ngZone;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimePicker.prototype._viewContainerRef;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimePicker.prototype._dateAdapter;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimePicker.prototype._dir;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimePicker.prototype._document;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: lib/datetime-input.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * \\@docs-private\r\n * @type {?}\r\n */\n\n\nconst MAT_DATEPICKER_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(\n  /**\r\n  * @return {?}\r\n  */\n  () => NgxMatDatetimeInput),\n  multi: true\n};\n/**\r\n * \\@docs-private\r\n * @type {?}\r\n */\n\nconst MAT_DATEPICKER_VALIDATORS = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(\n  /**\r\n  * @return {?}\r\n  */\n  () => NgxMatDatetimeInput),\n  multi: true\n};\n/**\r\n * An event used for datepicker input and change events. We don't always have access to a native\r\n * input or change event because the event may have been triggered by the user clicking on the\r\n * calendar popup. For consistency, we always use MatDatetimePickerInputEvent instead.\r\n * @template D\r\n */\n\nclass MatDatetimePickerInputEvent {\n  /**\r\n   * @param {?} target\r\n   * @param {?} targetElement\r\n   */\n  constructor(target, targetElement) {\n    this.target = target;\n    this.targetElement = targetElement;\n    this.value = this.target.value;\n  }\n\n}\n\nif (false) {\n  /**\r\n   * The new value for the target datepicker input.\r\n   * @type {?}\r\n   */\n  MatDatetimePickerInputEvent.prototype.value;\n  /**\r\n   * Reference to the datepicker input component that emitted the event.\r\n   * @type {?}\r\n   */\n\n  MatDatetimePickerInputEvent.prototype.target;\n  /**\r\n   * Reference to the native input element associated with the datepicker input.\r\n   * @type {?}\r\n   */\n\n  MatDatetimePickerInputEvent.prototype.targetElement;\n}\n/**\r\n * Directive used to connect an input to a matDatetimePicker.\r\n * @template D\r\n */\n\n\nlet NgxMatDatetimeInput = /*#__PURE__*/(() => {\n  class NgxMatDatetimeInput {\n    /**\r\n     * @param {?} _elementRef\r\n     * @param {?} _dateAdapter\r\n     * @param {?} _dateFormats\r\n     * @param {?} _formField\r\n     */\n    constructor(_elementRef, _dateAdapter, _dateFormats, _formField) {\n      this._elementRef = _elementRef;\n      this._dateAdapter = _dateAdapter;\n      this._dateFormats = _dateFormats;\n      this._formField = _formField;\n      /**\r\n       * Emits when a `change` event is fired on this `<input>`.\r\n       */\n\n      this.dateChange = new EventEmitter();\n      /**\r\n       * Emits when an `input` event is fired on this `<input>`.\r\n       */\n\n      this.dateInput = new EventEmitter();\n      /**\r\n       * Emits when the value changes (either due to user input or programmatic change).\r\n       */\n\n      this._valueChange = new EventEmitter();\n      /**\r\n       * Emits when the disabled state has changed\r\n       */\n\n      this.stateChanges = new EventEmitter();\n\n      this._onTouched =\n      /**\r\n      * @return {?}\r\n      */\n      () => {};\n\n      this._cvaOnChange =\n      /**\r\n      * @return {?}\r\n      */\n      () => {};\n\n      this._validatorOnChange =\n      /**\r\n      * @return {?}\r\n      */\n      () => {};\n\n      this._datepickerSubscription = Subscription.EMPTY;\n      this._localeSubscription = Subscription.EMPTY;\n      /**\r\n       * The form control validator for whether the input parses.\r\n       */\n\n      this._parseValidator =\n      /**\r\n      * @return {?}\r\n      */\n      () => {\n        return this._lastValueValid ? null : {\n          'matDatetimePickerParse': {\n            'text': this._elementRef.nativeElement.value\n          }\n        };\n      };\n      /**\r\n       * The form control validator for the min date.\r\n       */\n\n\n      this._minValidator =\n      /**\r\n      * @param {?} control\r\n      * @return {?}\r\n      */\n      control => {\n        /** @type {?} */\n        const controlValue = this._getValidDateOrNull(this._dateAdapter.deserialize(control.value));\n\n        return !this.min || !controlValue || this._dateAdapter.compareDateWithTime(this.min, controlValue, this._datepicker.showSeconds) <= 0 ? null : {\n          'matDatetimePickerMin': {\n            'min': this.min,\n            'actual': controlValue\n          }\n        };\n      };\n      /**\r\n       * The form control validator for the max date.\r\n       */\n\n\n      this._maxValidator =\n      /**\r\n      * @param {?} control\r\n      * @return {?}\r\n      */\n      control => {\n        /** @type {?} */\n        const controlValue = this._getValidDateOrNull(this._dateAdapter.deserialize(control.value));\n\n        return !this.max || !controlValue || this._dateAdapter.compareDateWithTime(this.max, controlValue, this._datepicker.showSeconds) >= 0 ? null : {\n          'matDatetimePickerMax': {\n            'max': this.max,\n            'actual': controlValue\n          }\n        };\n      };\n      /**\r\n       * The form control validator for the date filter.\r\n       */\n\n\n      this._filterValidator =\n      /**\r\n      * @param {?} control\r\n      * @return {?}\r\n      */\n      control => {\n        /** @type {?} */\n        const controlValue = this._getValidDateOrNull(this._dateAdapter.deserialize(control.value));\n\n        return !this._dateFilter || !controlValue || this._dateFilter(controlValue) ? null : {\n          'matDatetimePickerFilter': true\n        };\n      };\n      /**\r\n       * The combined form control validator for this input.\r\n       */\n\n\n      this._validator = Validators.compose([this._parseValidator, this._minValidator, this._maxValidator, this._filterValidator]);\n      /**\r\n       * Whether the last value set on the input was valid.\r\n       */\n\n      this._lastValueValid = false;\n\n      if (!this._dateAdapter) {\n        throw createMissingDateImplError('NgxMatDateAdapter');\n      }\n\n      if (!this._dateFormats) {\n        throw createMissingDateImplError('NGX_MAT_DATE_FORMATS');\n      } // Update the displayed date when the locale changes.\n\n\n      this._localeSubscription = _dateAdapter.localeChanges.subscribe(\n      /**\r\n      * @return {?}\r\n      */\n      () => {\n        this.value = this.value;\n      });\n    }\n    /**\r\n     * The datepicker that this input is associated with.\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set ngxMatDatetimePicker(value) {\n      if (!value) {\n        return;\n      }\n\n      this._datepicker = value;\n\n      this._datepicker._registerInput(this);\n\n      this._datepickerSubscription.unsubscribe();\n\n      this._datepickerSubscription = this._datepicker._selectedChanged.subscribe(\n      /**\r\n      * @param {?} selected\r\n      * @return {?}\r\n      */\n      selected => {\n        this.value = selected;\n\n        this._cvaOnChange(selected);\n\n        this._onTouched();\n\n        this.dateInput.emit(new MatDatetimePickerInputEvent(this, this._elementRef.nativeElement));\n        this.dateChange.emit(new MatDatetimePickerInputEvent(this, this._elementRef.nativeElement));\n      });\n    }\n    /**\r\n     * Function that can be used to filter out dates within the datepicker.\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set ngxMatDatetimePickerFilter(value) {\n      this._dateFilter = value;\n\n      this._validatorOnChange();\n    }\n    /**\r\n     * The value of the input.\r\n     * @return {?}\r\n     */\n\n\n    get value() {\n      return this._value;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set value(value) {\n      value = this._dateAdapter.deserialize(value);\n      this._lastValueValid = !value || this._dateAdapter.isValid(value);\n      value = this._getValidDateOrNull(value);\n      /** @type {?} */\n\n      const oldDate = this.value;\n      this._value = value;\n\n      this._formatValue(value);\n\n      if (!this._dateAdapter.sameDate(oldDate, value)) {\n        this._valueChange.emit(value);\n      }\n    }\n    /**\r\n     * The minimum valid date.\r\n     * @return {?}\r\n     */\n\n\n    get min() {\n      return this._min;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set min(value) {\n      this._min = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n\n      this._validatorOnChange();\n    }\n    /**\r\n     * The maximum valid date.\r\n     * @return {?}\r\n     */\n\n\n    get max() {\n      return this._max;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set max(value) {\n      this._max = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n\n      this._validatorOnChange();\n    }\n    /**\r\n     * Whether the datepicker-input is disabled.\r\n     * @return {?}\r\n     */\n\n\n    get disabled() {\n      return !!this._disabled;\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    set disabled(value) {\n      /** @type {?} */\n      const newValue = value != null && `${value}` !== 'false';\n      /** @type {?} */\n\n      const element = this._elementRef.nativeElement;\n\n      if (this._disabled !== newValue) {\n        this._disabled = newValue;\n        this.stateChanges.emit(undefined);\n      } // We need to null check the `blur` method, because it's undefined during SSR.\n\n\n      if (newValue && element.blur) {\n        // Normally, native input elements automatically blur if they turn disabled. This behavior\n        // is problematic, because it would mean that it triggers another change detection cycle,\n        // which then causes a changed after checked error if the input element was focused before.\n        element.blur();\n      }\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    ngOnDestroy() {\n      this._datepickerSubscription.unsubscribe();\n\n      this._localeSubscription.unsubscribe();\n\n      this._valueChange.complete();\n\n      this.stateChanges.complete();\n    }\n    /**\r\n     * \\@docs-private\r\n     * @param {?} fn\r\n     * @return {?}\r\n     */\n\n\n    registerOnValidatorChange(fn) {\n      this._validatorOnChange = fn;\n    }\n    /**\r\n     * \\@docs-private\r\n     * @param {?} c\r\n     * @return {?}\r\n     */\n\n\n    validate(c) {\n      return this._validator ? this._validator(c) : null;\n    }\n    /**\r\n     * @deprecated\r\n     * \\@breaking-change 8.0.0 Use `getConnectedOverlayOrigin` instead\r\n     * @return {?}\r\n     */\n\n\n    getPopupConnectionElementRef() {\n      return this.getConnectedOverlayOrigin();\n    }\n    /**\r\n     * Gets the element that the datepicker popup should be connected to.\r\n     * @return {?} The element to connect the popup to.\r\n     */\n\n\n    getConnectedOverlayOrigin() {\n      return this._formField ? this._formField.getConnectedOverlayOrigin() : this._elementRef;\n    } // Implemented as part of ControlValueAccessor.\n\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    writeValue(value) {\n      this.value = value;\n    } // Implemented as part of ControlValueAccessor.\n\n    /**\r\n     * @param {?} fn\r\n     * @return {?}\r\n     */\n\n\n    registerOnChange(fn) {\n      this._cvaOnChange = fn;\n    } // Implemented as part of ControlValueAccessor.\n\n    /**\r\n     * @param {?} fn\r\n     * @return {?}\r\n     */\n\n\n    registerOnTouched(fn) {\n      this._onTouched = fn;\n    } // Implemented as part of ControlValueAccessor.\n\n    /**\r\n     * @param {?} isDisabled\r\n     * @return {?}\r\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n    }\n    /**\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\n\n\n    _onKeydown(event) {\n      /** @type {?} */\n      const isAltDownArrow = event.altKey && event.keyCode === DOWN_ARROW;\n\n      if (this._datepicker && isAltDownArrow && !this._elementRef.nativeElement.readOnly) {\n        this._datepicker.open();\n\n        event.preventDefault();\n      }\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    _onInput(value) {\n      /** @type {?} */\n      const lastValueWasValid = this._lastValueValid;\n      /** @type {?} */\n\n      let date = this._dateAdapter.parse(value, this._dateFormats.parse.dateInput);\n\n      this._lastValueValid = !date || this._dateAdapter.isValid(date);\n      date = this._getValidDateOrNull(date);\n      /** @type {?} */\n\n      const isSameTime = this._dateAdapter.isSameTime(date, this._value);\n\n      if (date != null && (!isSameTime || !this._dateAdapter.sameDate(date, this._value)) || date == null && this._value != null) {\n        this._value = date;\n\n        this._cvaOnChange(date);\n\n        this._valueChange.emit(date);\n\n        this.dateInput.emit(new MatDatetimePickerInputEvent(this, this._elementRef.nativeElement));\n      } else if (lastValueWasValid !== this._lastValueValid) {\n        this._validatorOnChange();\n      }\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    _onChange() {\n      this.dateChange.emit(new MatDatetimePickerInputEvent(this, this._elementRef.nativeElement));\n    }\n    /**\r\n     * Returns the palette used by the input's form field, if any.\r\n     * @return {?}\r\n     */\n\n\n    _getThemePalette() {\n      return this._formField ? this._formField.color : undefined;\n    }\n    /**\r\n     * Handles blur events on the input.\r\n     * @return {?}\r\n     */\n\n\n    _onBlur() {\n      // Reformat the input only if we have a valid value.\n      if (this.value) {\n        this._formatValue(this.value);\n      }\n\n      this._onTouched();\n    }\n    /**\r\n     * Handles focus events on the input.\r\n     * @return {?}\r\n     */\n\n\n    _onFocus() {\n      // Close datetime picker if opened\n      if (this._datepicker && this._datepicker.opened) {\n        this._datepicker.cancel();\n      }\n    }\n    /**\r\n     * Formats a value and sets it on the input element.\r\n     * @private\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    _formatValue(value) {\n      this._elementRef.nativeElement.value = value ? this._dateAdapter.format(value, this._dateFormats.display.dateInput) : '';\n    }\n    /**\r\n     * @private\r\n     * @param {?} obj The object to check.\r\n     * @return {?} The given object if it is both a date instance and valid, otherwise null.\r\n     */\n\n\n    _getValidDateOrNull(obj) {\n      return this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj) ? obj : null;\n    }\n\n  }\n\n  NgxMatDatetimeInput.ɵfac = function NgxMatDatetimeInput_Factory(t) {\n    return new (t || NgxMatDatetimeInput)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NgxMatDateAdapter, 8), ɵngcc0.ɵɵdirectiveInject(NGX_MAT_DATE_FORMATS, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc7.MatFormField, 8));\n  };\n\n  NgxMatDatetimeInput.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: NgxMatDatetimeInput,\n    selectors: [[\"input\", \"ngxMatDatetimePicker\", \"\"]],\n    hostVars: 5,\n    hostBindings: function NgxMatDatetimeInput_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"input\", function NgxMatDatetimeInput_input_HostBindingHandler($event) {\n          return ctx._onInput($event.target.value);\n        })(\"change\", function NgxMatDatetimeInput_change_HostBindingHandler() {\n          return ctx._onChange();\n        })(\"blur\", function NgxMatDatetimeInput_blur_HostBindingHandler() {\n          return ctx._onBlur();\n        })(\"focus\", function NgxMatDatetimeInput_focus_HostBindingHandler() {\n          return ctx._onFocus();\n        })(\"keydown\", function NgxMatDatetimeInput_keydown_HostBindingHandler($event) {\n          return ctx._onKeydown($event);\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵhostProperty(\"disabled\", ctx.disabled);\n        ɵngcc0.ɵɵattribute(\"aria-haspopup\", ctx._datepicker ? \"dialog\" : null)(\"aria-owns\", (ctx._datepicker == null ? null : ctx._datepicker.opened) && ctx._datepicker.id || null)(\"min\", ctx.min ? ctx._dateAdapter.toIso8601(ctx.min) : null)(\"max\", ctx.max ? ctx._dateAdapter.toIso8601(ctx.max) : null);\n      }\n    },\n    inputs: {\n      value: \"value\",\n      ngxMatDatetimePicker: \"ngxMatDatetimePicker\",\n      ngxMatDatetimePickerFilter: \"ngxMatDatetimePickerFilter\",\n      min: \"min\",\n      max: \"max\",\n      disabled: \"disabled\"\n    },\n    outputs: {\n      dateChange: \"dateChange\",\n      dateInput: \"dateInput\"\n    },\n    exportAs: [\"ngxMatDatetimePickerInput\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([MAT_DATEPICKER_VALUE_ACCESSOR, MAT_DATEPICKER_VALIDATORS, {\n      provide: MAT_INPUT_VALUE_ACCESSOR,\n      useExisting: NgxMatDatetimeInput\n    }])]\n  });\n  /** @nocollapse */\n\n  return NgxMatDatetimeInput;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /** @type {?} */\n  NgxMatDatetimeInput.prototype._datepicker;\n  /** @type {?} */\n\n  NgxMatDatetimeInput.prototype._dateFilter;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimeInput.prototype._value;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimeInput.prototype._min;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimeInput.prototype._max;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimeInput.prototype._disabled;\n  /**\r\n   * Emits when a `change` event is fired on this `<input>`.\r\n   * @type {?}\r\n   */\n\n  NgxMatDatetimeInput.prototype.dateChange;\n  /**\r\n   * Emits when an `input` event is fired on this `<input>`.\r\n   * @type {?}\r\n   */\n\n  NgxMatDatetimeInput.prototype.dateInput;\n  /**\r\n   * Emits when the value changes (either due to user input or programmatic change).\r\n   * @type {?}\r\n   */\n\n  NgxMatDatetimeInput.prototype._valueChange;\n  /**\r\n   * Emits when the disabled state has changed\r\n   * @type {?}\r\n   */\n\n  NgxMatDatetimeInput.prototype.stateChanges;\n  /** @type {?} */\n\n  NgxMatDatetimeInput.prototype._onTouched;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimeInput.prototype._cvaOnChange;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimeInput.prototype._validatorOnChange;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimeInput.prototype._datepickerSubscription;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimeInput.prototype._localeSubscription;\n  /**\r\n   * The form control validator for whether the input parses.\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimeInput.prototype._parseValidator;\n  /**\r\n   * The form control validator for the min date.\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimeInput.prototype._minValidator;\n  /**\r\n   * The form control validator for the max date.\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimeInput.prototype._maxValidator;\n  /**\r\n   * The form control validator for the date filter.\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimeInput.prototype._filterValidator;\n  /**\r\n   * The combined form control validator for this input.\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimeInput.prototype._validator;\n  /**\r\n   * Whether the last value set on the input was valid.\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimeInput.prototype._lastValueValid;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimeInput.prototype._elementRef;\n  /** @type {?} */\n\n  NgxMatDatetimeInput.prototype._dateAdapter;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimeInput.prototype._dateFormats;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxMatDatetimeInput.prototype._formField;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: lib/timepicker.module.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n\nlet NgxMatTimepickerModule = /*#__PURE__*/(() => {\n  class NgxMatTimepickerModule {}\n\n  NgxMatTimepickerModule.ɵfac = function NgxMatTimepickerModule_Factory(t) {\n    return new (t || NgxMatTimepickerModule)();\n  };\n\n  NgxMatTimepickerModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: NgxMatTimepickerModule\n  });\n  NgxMatTimepickerModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, MatInputModule, ReactiveFormsModule, FormsModule, MatIconModule, MatButtonModule]]\n  });\n  return NgxMatTimepickerModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxMatTimepickerModule, {\n    declarations: function () {\n      return [NgxMatTimepickerComponent];\n    },\n    imports: function () {\n      return [CommonModule, MatInputModule, ReactiveFormsModule, FormsModule, MatIconModule, MatButtonModule];\n    },\n    exports: function () {\n      return [NgxMatTimepickerComponent];\n    }\n  });\n})();\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: lib/datetime-picker.module.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n\nlet NgxMatDatetimePickerModule = /*#__PURE__*/(() => {\n  class NgxMatDatetimePickerModule {}\n\n  NgxMatDatetimePickerModule.ɵfac = function NgxMatDatetimePickerModule_Factory(t) {\n    return new (t || NgxMatDatetimePickerModule)();\n  };\n\n  NgxMatDatetimePickerModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: NgxMatDatetimePickerModule\n  });\n  NgxMatDatetimePickerModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER, {\n      provide: NGX_MAT_DATE_RANGE_SELECTION_STRATEGY,\n      useClass: DefaultNgxMatCalendarRangeStrategy\n    }],\n    imports: [[CommonModule, MatDatepickerModule, MatDialogModule, PortalModule, FormsModule, MatIconModule, MatButtonModule, MatInputModule, NgxMatTimepickerModule]]\n  });\n  return NgxMatDatetimePickerModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxMatDatetimePickerModule, {\n    declarations: function () {\n      return [NgxMatDatetimePicker, NgxMatDatetimeContent, NgxMatDatetimeInput, NgxMatCalendar, NgxMatMonthView, NgxMatCalendarBody, NgxMatYearView, NgxMatMultiYearView, NgxMatCalendarHeader];\n    },\n    imports: function () {\n      return [CommonModule, MatDatepickerModule, MatDialogModule, PortalModule, FormsModule, MatIconModule, MatButtonModule, MatInputModule, NgxMatTimepickerModule];\n    },\n    exports: function () {\n      return [NgxMatDatetimePicker, NgxMatDatetimeInput, NgxMatCalendar, NgxMatMonthView, NgxMatCalendarBody, NgxMatYearView, NgxMatMultiYearView, NgxMatCalendarHeader];\n    }\n  });\n})();\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: lib/core/native-date-adapter.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n// TODO(mmalerba): Remove when we no longer support safari 9.\n\n/**\r\n * Whether the browser supports the Intl API.\r\n * @type {?}\r\n */\n\n\nlet SUPPORTS_INTL_API; // We need a try/catch around the reference to `Intl`, because accessing it in some cases can\n// cause IE to throw. These cases are tied to particular versions of Windows and can happen if\n// the consumer is providing a polyfilled `Map`. See:\n// https://github.com/Microsoft/ChakraCore/issues/3189\n// https://github.com/angular/components/issues/15687\n\ntry {\n  SUPPORTS_INTL_API = typeof Intl != 'undefined';\n} catch (_a) {\n  SUPPORTS_INTL_API = false;\n}\n/**\r\n * The default month names to use if Intl API is not available.\r\n * @type {?}\r\n */\n\n\nconst DEFAULT_MONTH_NAMES = {\n  'long': ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n  'short': ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n  'narrow': ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D']\n};\n\nconst ɵ0 =\n/**\r\n* @param {?} i\r\n* @return {?}\r\n*/\ni => String(i + 1);\n/**\r\n * The default date names to use if Intl API is not available.\r\n * @type {?}\r\n */\n\n\nconst DEFAULT_DATE_NAMES = range(31, ɵ0);\n/**\r\n * The default day of the week names to use if Intl API is not available.\r\n * @type {?}\r\n */\n\nconst DEFAULT_DAY_OF_WEEK_NAMES = {\n  'long': ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n  'short': ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n  'narrow': ['S', 'M', 'T', 'W', 'T', 'F', 'S']\n};\n/**\r\n * Matches strings that have the form of a valid RFC 3339 string\r\n * (https://tools.ietf.org/html/rfc3339). Note that the string may not actually be a valid date\r\n * because the regex will match strings an with out of bounds month, date, etc.\r\n * @type {?}\r\n */\n\nconst ISO_8601_REGEX = /^\\d{4}-\\d{2}-\\d{2}(?:T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|(?:(?:\\+|-)\\d{2}:\\d{2}))?)?$/;\n/**\r\n * Creates an array and fills it with values.\r\n * @template T\r\n * @param {?} length\r\n * @param {?} valueFunction\r\n * @return {?}\r\n */\n\nfunction range(length, valueFunction) {\n  /** @type {?} */\n  const valuesArray = Array(length);\n\n  for (let i = 0; i < length; i++) {\n    valuesArray[i] = valueFunction(i);\n  }\n\n  return valuesArray;\n}\n/**\r\n * Adapts the native JS Date for use with cdk-based components that work with dates.\r\n */\n\n\nlet NgxMatNativeDateAdapter = /*#__PURE__*/(() => {\n  class NgxMatNativeDateAdapter extends NgxMatDateAdapter {\n    /**\r\n     * @param {?} matDateLocale\r\n     * @param {?} platform\r\n     */\n    constructor(matDateLocale, platform) {\n      super();\n      /**\r\n       * Whether to use `timeZone: 'utc'` with `Intl.DateTimeFormat` when formatting dates.\r\n       * Without this `Intl.DateTimeFormat` sometimes chooses the wrong timeZone, which can throw off\r\n       * the result. (e.g. in the en-US locale `new Date(1800, 7, 14).toLocaleDateString()`\r\n       * will produce `'8/13/1800'`.\r\n       *\r\n       * TODO(mmalerba): drop this variable. It's not being used in the code right now. We're now\r\n       * getting the string representation of a Date object from its utc representation. We're keeping\r\n       * it here for sometime, just for precaution, in case we decide to revert some of these changes\r\n       * though.\r\n       */\n\n      this.useUtcForDisplay = true;\n      super.setLocale(matDateLocale); // IE does its own time zone correction, so we disable this on IE.\n\n      this.useUtcForDisplay = !platform.TRIDENT;\n      this._clampDate = platform.TRIDENT || platform.EDGE;\n    }\n    /**\r\n     * @param {?} date\r\n     * @return {?}\r\n     */\n\n\n    getYear(date) {\n      return date.getFullYear();\n    }\n    /**\r\n     * @param {?} date\r\n     * @return {?}\r\n     */\n\n\n    getMonth(date) {\n      return date.getMonth();\n    }\n    /**\r\n     * @param {?} date\r\n     * @return {?}\r\n     */\n\n\n    getDate(date) {\n      return date.getDate();\n    }\n    /**\r\n     * @param {?} date\r\n     * @return {?}\r\n     */\n\n\n    getDayOfWeek(date) {\n      return date.getDay();\n    }\n    /**\r\n     * @param {?} style\r\n     * @return {?}\r\n     */\n\n\n    getMonthNames(style) {\n      if (SUPPORTS_INTL_API) {\n        /** @type {?} */\n        const dtf = new Intl.DateTimeFormat(this.locale, {\n          month: style,\n          timeZone: 'utc'\n        });\n        return range(12,\n        /**\r\n        * @param {?} i\r\n        * @return {?}\r\n        */\n        i => this._stripDirectionalityCharacters(this._format(dtf, new Date(2017, i, 1))));\n      }\n\n      return DEFAULT_MONTH_NAMES[style];\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    getDateNames() {\n      if (SUPPORTS_INTL_API) {\n        /** @type {?} */\n        const dtf = new Intl.DateTimeFormat(this.locale, {\n          day: 'numeric',\n          timeZone: 'utc'\n        });\n        return range(31,\n        /**\r\n        * @param {?} i\r\n        * @return {?}\r\n        */\n        i => this._stripDirectionalityCharacters(this._format(dtf, new Date(2017, 0, i + 1))));\n      }\n\n      return DEFAULT_DATE_NAMES;\n    }\n    /**\r\n     * @param {?} style\r\n     * @return {?}\r\n     */\n\n\n    getDayOfWeekNames(style) {\n      if (SUPPORTS_INTL_API) {\n        /** @type {?} */\n        const dtf = new Intl.DateTimeFormat(this.locale, {\n          weekday: style,\n          timeZone: 'utc'\n        });\n        return range(7,\n        /**\r\n        * @param {?} i\r\n        * @return {?}\r\n        */\n        i => this._stripDirectionalityCharacters(this._format(dtf, new Date(2017, 0, i + 1))));\n      }\n\n      return DEFAULT_DAY_OF_WEEK_NAMES[style];\n    }\n    /**\r\n     * @param {?} date\r\n     * @return {?}\r\n     */\n\n\n    getYearName(date) {\n      if (SUPPORTS_INTL_API) {\n        /** @type {?} */\n        const dtf = new Intl.DateTimeFormat(this.locale, {\n          year: 'numeric',\n          timeZone: 'utc'\n        });\n        return this._stripDirectionalityCharacters(this._format(dtf, date));\n      }\n\n      return String(this.getYear(date));\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    getFirstDayOfWeek() {\n      // We can't tell using native JS Date what the first day of the week is, we default to Sunday.\n      return 0;\n    }\n    /**\r\n     * @param {?} date\r\n     * @return {?}\r\n     */\n\n\n    getNumDaysInMonth(date) {\n      return this.getDate(this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + 1, 0));\n    }\n    /**\r\n     * @param {?} date\r\n     * @return {?}\r\n     */\n\n\n    clone(date) {\n      return new Date(date.getTime());\n    }\n    /**\r\n     * @param {?} year\r\n     * @param {?} month\r\n     * @param {?} date\r\n     * @return {?}\r\n     */\n\n\n    createDate(year, month, date) {\n      // Check for invalid month and date (except upper bound on date which we have to check after\n      // creating the Date).\n      if (month < 0 || month > 11) {\n        throw Error(`Invalid month index \"${month}\". Month index has to be between 0 and 11.`);\n      }\n\n      if (date < 1) {\n        throw Error(`Invalid date \"${date}\". Date has to be greater than 0.`);\n      }\n      /** @type {?} */\n\n\n      let result = this._createDateWithOverflow(year, month, date); // Check that the date wasn't above the upper bound for the month, causing the month to overflow\n\n\n      if (result.getMonth() != month) {\n        throw Error(`Invalid date \"${date}\" for month with index \"${month}\".`);\n      }\n\n      return result;\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    today() {\n      return new Date();\n    }\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    parse(value) {\n      // We have no way using the native JS Date to set the parse format or locale, so we ignore these\n      // parameters.\n      if (typeof value == 'number') {\n        return new Date(value);\n      }\n\n      return value ? new Date(Date.parse(value)) : null;\n    }\n    /**\r\n     * @param {?} date\r\n     * @param {?} displayFormat\r\n     * @return {?}\r\n     */\n\n\n    format(date, displayFormat) {\n      if (!this.isValid(date)) {\n        throw Error('NativeDateAdapter: Cannot format invalid date.');\n      }\n\n      if (SUPPORTS_INTL_API) {\n        // On IE and Edge the i18n API will throw a hard error that can crash the entire app\n        // if we attempt to format a date whose year is less than 1 or greater than 9999.\n        if (this._clampDate && (date.getFullYear() < 1 || date.getFullYear() > 9999)) {\n          date = this.clone(date);\n          date.setFullYear(Math.max(1, Math.min(9999, date.getFullYear())));\n        }\n\n        displayFormat = Object.assign(Object.assign({}, displayFormat), {\n          timeZone: 'utc'\n        });\n        /** @type {?} */\n\n        const dtf = new Intl.DateTimeFormat(this.locale, displayFormat);\n        return this._stripDirectionalityCharacters(this._format(dtf, date));\n      }\n\n      return this._stripDirectionalityCharacters(date.toDateString());\n    }\n    /**\r\n     * @param {?} date\r\n     * @param {?} years\r\n     * @return {?}\r\n     */\n\n\n    addCalendarYears(date, years) {\n      return this.addCalendarMonths(date, years * 12);\n    }\n    /**\r\n     * @param {?} date\r\n     * @param {?} months\r\n     * @return {?}\r\n     */\n\n\n    addCalendarMonths(date, months) {\n      /** @type {?} */\n      let newDate = this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + months, this.getDate(date)); // It's possible to wind up in the wrong month if the original month has more days than the new\n      // month. In this case we want to go to the last day of the desired month.\n      // Note: the additional + 12 % 12 ensures we end up with a positive number, since JS % doesn't\n      // guarantee this.\n\n\n      if (this.getMonth(newDate) != ((this.getMonth(date) + months) % 12 + 12) % 12) {\n        newDate = this._createDateWithOverflow(this.getYear(newDate), this.getMonth(newDate), 0);\n      }\n\n      return newDate;\n    }\n    /**\r\n     * @param {?} date\r\n     * @param {?} days\r\n     * @return {?}\r\n     */\n\n\n    addCalendarDays(date, days) {\n      return this._createDateWithOverflow(this.getYear(date), this.getMonth(date), this.getDate(date) + days);\n    }\n    /**\r\n     * @param {?} date\r\n     * @return {?}\r\n     */\n\n\n    toIso8601(date) {\n      return [date.getUTCFullYear(), this._2digit(date.getUTCMonth() + 1), this._2digit(date.getUTCDate())].join('-');\n    }\n    /**\r\n     * Returns the given value if given a valid Date or null. Deserializes valid ISO 8601 strings\r\n     * (https://www.ietf.org/rfc/rfc3339.txt) into valid Dates and empty string into null. Returns an\r\n     * invalid date for all other values.\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    deserialize(value) {\n      if (typeof value === 'string') {\n        if (!value) {\n          return null;\n        } // The `Date` constructor accepts formats other than ISO 8601, so we need to make sure the\n        // string is the right format first.\n\n\n        if (ISO_8601_REGEX.test(value)) {\n          /** @type {?} */\n          let date = new Date(value);\n\n          if (this.isValid(date)) {\n            return date;\n          }\n        }\n      }\n\n      return super.deserialize(value);\n    }\n    /**\r\n     * @param {?} obj\r\n     * @return {?}\r\n     */\n\n\n    isDateInstance(obj) {\n      return obj instanceof Date;\n    }\n    /**\r\n     * @param {?} date\r\n     * @return {?}\r\n     */\n\n\n    isValid(date) {\n      return !isNaN(date.getTime());\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    invalid() {\n      return new Date(NaN);\n    }\n    /**\r\n     * @param {?} date\r\n     * @return {?}\r\n     */\n\n\n    getHour(date) {\n      return date.getHours();\n    }\n    /**\r\n     * @param {?} date\r\n     * @return {?}\r\n     */\n\n\n    getMinute(date) {\n      return date.getMinutes();\n    }\n    /**\r\n     * @param {?} date\r\n     * @return {?}\r\n     */\n\n\n    getSecond(date) {\n      return date.getSeconds();\n    }\n    /**\r\n     * @param {?} date\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    setHour(date, value) {\n      date.setHours(value);\n    }\n    /**\r\n     * @param {?} date\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    setMinute(date, value) {\n      date.setMinutes(value);\n    }\n    /**\r\n     * @param {?} date\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n\n    setSecond(date, value) {\n      date.setSeconds(value);\n    }\n    /**\r\n     * Creates a date but allows the month and date to overflow.\r\n     * @private\r\n     * @param {?} year\r\n     * @param {?} month\r\n     * @param {?} date\r\n     * @return {?}\r\n     */\n\n\n    _createDateWithOverflow(year, month, date) {\n      /** @type {?} */\n      const result = new Date(year, month, date); // We need to correct for the fact that JS native Date treats years in range [0, 99] as\n      // abbreviations for 19xx.\n\n      if (year >= 0 && year < 100) {\n        result.setFullYear(this.getYear(result) - 1900);\n      }\n\n      return result;\n    }\n    /**\r\n     * Pads a number to make it two digits.\r\n     * @private\r\n     * @param {?} n The number to pad.\r\n     * @return {?} The padded number.\r\n     */\n\n\n    _2digit(n) {\n      return ('00' + n).slice(-2);\n    }\n    /**\r\n     * Strip out unicode LTR and RTL characters. Edge and IE insert these into formatted dates while\r\n     * other browsers do not. We remove them to make output consistent and because they interfere with\r\n     * date parsing.\r\n     * @private\r\n     * @param {?} str The string to strip direction characters from.\r\n     * @return {?} The stripped string.\r\n     */\n\n\n    _stripDirectionalityCharacters(str) {\n      return str.replace(/[\\u200e\\u200f]/g, '');\n    }\n    /**\r\n     * When converting Date object to string, javascript built-in functions may return wrong\r\n     * results because it applies its internal DST rules. The DST rules around the world change\r\n     * very frequently, and the current valid rule is not always valid in previous years though.\r\n     * We work around this problem building a new Date object which has its internal UTC\r\n     * representation with the local date and time.\r\n     * @private\r\n     * @param {?} dtf Intl.DateTimeFormat object, containg the desired string format. It must have\r\n     *    timeZone set to 'utc' to work fine.\r\n     * @param {?} date Date from which we want to get the string representation according to dtf\r\n     * @return {?} A Date object with its UTC representation based on the passed in date info\r\n     */\n\n\n    _format(dtf, date) {\n      // Passing the year to the constructor causes year numbers <100 to be converted to 19xx.\n      // To work around this we use `setUTCFullYear` and `setUTCHours` instead.\n\n      /** @type {?} */\n      const d = new Date();\n      d.setUTCFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n      d.setUTCHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());\n      return dtf.format(d);\n    }\n\n  }\n\n  NgxMatNativeDateAdapter.ɵfac = function NgxMatNativeDateAdapter_Factory(t) {\n    return new (t || NgxMatNativeDateAdapter)(ɵngcc0.ɵɵinject(MAT_DATE_LOCALE, 8), ɵngcc0.ɵɵinject(ɵngcc12.Platform));\n  };\n\n  NgxMatNativeDateAdapter.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: NgxMatNativeDateAdapter,\n    factory: NgxMatNativeDateAdapter.ɵfac\n  });\n  /** @nocollapse */\n\n  return NgxMatNativeDateAdapter;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\r\n   * Whether to clamp the date between 1 and 9999 to avoid IE and Edge errors.\r\n   * @type {?}\r\n   * @private\r\n   */\n  NgxMatNativeDateAdapter.prototype._clampDate;\n  /**\r\n   * Whether to use `timeZone: 'utc'` with `Intl.DateTimeFormat` when formatting dates.\r\n   * Without this `Intl.DateTimeFormat` sometimes chooses the wrong timeZone, which can throw off\r\n   * the result. (e.g. in the en-US locale `new Date(1800, 7, 14).toLocaleDateString()`\r\n   * will produce `'8/13/1800'`.\r\n   *\r\n   * TODO(mmalerba): drop this variable. It's not being used in the code right now. We're now\r\n   * getting the string representation of a Date object from its utc representation. We're keeping\r\n   * it here for sometime, just for precaution, in case we decide to revert some of these changes\r\n   * though.\r\n   * @type {?}\r\n   */\n\n  NgxMatNativeDateAdapter.prototype.useUtcForDisplay;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: lib/core/native-date-formats.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n * @type {?}\r\n */\n\n\nconst DEFAULT_DATE_INPUT = {\n  year: 'numeric',\n  month: 'numeric',\n  day: 'numeric',\n  hour12: false,\n  hour: \"2-digit\",\n  minute: \"2-digit\",\n  second: \"2-digit\"\n};\n/** @type {?} */\n\nconst NGX_MAT_NATIVE_DATE_FORMATS = {\n  parse: {\n    dateInput: DEFAULT_DATE_INPUT\n  },\n  display: {\n    dateInput: DEFAULT_DATE_INPUT,\n    monthYearLabel: {\n      year: 'numeric',\n      month: 'short'\n    },\n    dateA11yLabel: {\n      year: 'numeric',\n      month: 'long',\n      day: 'numeric'\n    },\n    monthYearA11yLabel: {\n      year: 'numeric',\n      month: 'long'\n    }\n  }\n};\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: lib/core/native-date.module.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\nlet NgxNativeDateModule = /*#__PURE__*/(() => {\n  class NgxNativeDateModule {}\n\n  NgxNativeDateModule.ɵfac = function NgxNativeDateModule_Factory(t) {\n    return new (t || NgxNativeDateModule)();\n  };\n\n  NgxNativeDateModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: NgxNativeDateModule\n  });\n  NgxNativeDateModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [{\n      provide: NgxMatDateAdapter,\n      useClass: NgxMatNativeDateAdapter\n    }],\n    imports: [[PlatformModule]]\n  });\n  return NgxNativeDateModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxNativeDateModule, {\n    imports: function () {\n      return [PlatformModule];\n    }\n  });\n})();\n\nconst ɵ0$1 = NGX_MAT_NATIVE_DATE_FORMATS;\nlet NgxMatNativeDateModule = /*#__PURE__*/(() => {\n  class NgxMatNativeDateModule {}\n\n  NgxMatNativeDateModule.ɵfac = function NgxMatNativeDateModule_Factory(t) {\n    return new (t || NgxMatNativeDateModule)();\n  };\n\n  NgxMatNativeDateModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: NgxMatNativeDateModule\n  });\n  NgxMatNativeDateModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [{\n      provide: NGX_MAT_DATE_FORMATS,\n      useValue: ɵ0$1\n    }],\n    imports: [[NgxNativeDateModule]]\n  });\n  return NgxMatNativeDateModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxMatNativeDateModule, {\n    imports: [NgxNativeDateModule]\n  });\n})();\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: public-api.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: angular-material-components-datetime-picker.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n\nexport { DefaultNgxMatCalendarRangeStrategy, MAT_DATEPICKER_VALIDATORS, MAT_DATEPICKER_VALUE_ACCESSOR, MatDatetimePickerInputEvent, NGX_MAT_DATE_FORMATS, NGX_MAT_DATE_RANGE_SELECTION_STRATEGY, NGX_MAT_NATIVE_DATE_FORMATS, NgxMatCalendar, NgxMatCalendarBody, NgxMatCalendarCell, NgxMatCalendarHeader, NgxMatDateAdapter, NgxMatDatetimeContent, NgxMatDatetimeInput, NgxMatDatetimePicker, NgxMatDatetimePickerModule, NgxMatMonthView, NgxMatMultiYearView, NgxMatNativeDateAdapter, NgxMatNativeDateModule, NgxMatTimepickerComponent, NgxMatTimepickerModule, NgxMatYearView, NgxNativeDateModule, getActiveOffset, isSameMultiYearView, yearsPerPage, yearsPerRow }; //# sourceMappingURL=angular-material-components-datetime-picker.js.map","map":null,"metadata":{},"sourceType":"module"}