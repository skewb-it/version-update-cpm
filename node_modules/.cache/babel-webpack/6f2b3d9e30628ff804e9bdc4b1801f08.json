{"ast":null,"code":"import { Validators } from '@angular/forms';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/forms\";\nexport let ValidationService = /*#__PURE__*/(() => {\n  class ValidationService {\n    constructor(formBuilder) {\n      this.formBuilder = formBuilder;\n    }\n\n    createFormGroup(formData) {\n      const group = this.formBuilder.group({}, {\n        validator: this.bindValidations(formData.groupValidations)\n      });\n\n      if (formData && formData.controls) {\n        formData.controls.forEach(formControl => {\n          if (formControl.controlType == \"formarray\") {\n            let control = null;\n\n            if (formControl && formControl.controls) {\n              control = this.formBuilder.array([this.createFormGroup(formControl)]);\n            } else {\n              control = this.formBuilder.array([]);\n            }\n\n            group.addControl(formControl.controlName, control);\n          } else {\n            let validation = null;\n            validation = this.bindValidations(formControl.validations || []);\n            const control = this.formBuilder.control(formControl.value, validation);\n            group.addControl(formControl.controlName, control);\n          }\n        });\n      }\n\n      return group;\n    }\n\n    getValidator(validation) {\n      switch (validation.name) {\n        case \"required\":\n          validation.defaultMessage = 'This field is required';\n          return ValidationService.validatorFn(validation, Validators.required);\n\n        case \"minlength\":\n          validation.defaultMessage = `Min length is ${validation.params}`;\n          return ValidationService.validatorFn(validation, Validators.minLength(validation.params));\n\n        case \"maxlength\":\n          validation.defaultMessage = `Max length is ${validation.params}`;\n          return ValidationService.validatorFn(validation, Validators.maxLength(validation.params));\n\n        case \"min\":\n          validation.defaultMessage = `Minimum number can be ${validation.params}`;\n          return ValidationService.validatorFn(validation, Validators.min(validation.params));\n\n        case \"max\":\n          validation.defaultMessage = `Maximum  required number is ${validation.params}`;\n          return ValidationService.validatorFn(validation, Validators.max(validation.params));\n\n        case \"email\":\n          validation.defaultMessage = 'Please enter a valid email address';\n          return ValidationService.validatorFn(validation, Validators.email);\n\n        case \"pattern\":\n          validation.defaultMessage = 'This field is invalid';\n          return ValidationService.validatorFn(validation, Validators.pattern(validation.params));\n\n        case \"dateCompare\":\n          validation.defaultMessage = 'Invalid field';\n          return ValidationService.dateCompare(validation);\n\n        case \"dataCompare\":\n          validation.defaultMessage = 'fields should match';\n          return ValidationService.dataCompare(validation);\n\n        case \"bothDateCheck\":\n          validation.defaultMessage = 'Both fields are required';\n          return ValidationService.bothDateCheck(validation);\n      }\n    }\n\n    bindValidations(validations) {\n      if (validations && validations.length > 0) {\n        const validList = [];\n        validations.forEach(validation => {\n          let validator;\n          validator = this.getValidator(validation);\n          validList.push(validator);\n        });\n        return Validators.compose(validList);\n      }\n\n      return null;\n    }\n\n    static dataCompare(validation) {\n      return group => {\n        if (group) {\n          const field1Value = group.get(validation.field1) ? group.get(validation.field1).value : null;\n          const field2Value = group.get(validation.field2) ? group.get(validation.field2).value : null;\n\n          if (field1Value && field2Value) {\n            let validateResult = false;\n            eval(`validateResult = field1Value.valueOf() ${validation.operator} field2Value.valueOf()`);\n\n            if (!validateResult) {\n              let errorData = {};\n              let errorMessage = ValidationService.getErrorMessage(validation, null, null, group);\n              errorData[validation.name] = {\n                errorMessage: errorMessage\n              };\n              return errorData;\n            }\n\n            return null;\n          }\n\n          return null;\n        }\n\n        return null;\n      };\n    }\n\n    static dateCompare(validation) {\n      return group => {\n        if (group) {\n          const dateString1 = group.get(validation.field1) ? group.get(validation.field1).value : null;\n          const dateString2 = group.get(validation.field2) ? group.get(validation.field2).value : null;\n\n          if (dateString1 && dateString2) {\n            const field1 = new Date(dateString1);\n            const field2 = new Date(dateString2);\n            let validateResult = false;\n            eval(`validateResult = field1.valueOf() ${validation.operator} field2.valueOf()`);\n\n            if (!validateResult) {\n              let errorData = {};\n              let errorMessage = ValidationService.getErrorMessage(validation, null, null, group);\n              errorData[validation.name] = {\n                errorMessage: errorMessage\n              };\n              return errorData;\n            }\n\n            return null;\n          }\n\n          return null;\n        }\n\n        return null;\n      };\n    }\n\n    static bothDateCheck(validation) {\n      return group => {\n        if (group) {\n          let dateString1 = group.get(validation.field1) ? group.get(validation.field1).value : null;\n          let dateString2 = group.get(validation.field2) ? group.get(validation.field2).value : null;\n          let errorData = {};\n          let errorMessage = ValidationService.getErrorMessage(validation, null, null, group);\n          errorData[validation.name] = {\n            errorMessage: errorMessage\n          };\n          dateString1 = dateString1 ? dateString1.toString() : '';\n          dateString2 = dateString2 ? dateString2.toString() : '';\n\n          if (dateString1.length > 0 || dateString2.length > 0) {\n            if (dateString1.length > 0 && dateString2.length == 0) {\n              return errorData;\n            } else if (dateString2.length > 0 && dateString1.length == 0) {\n              return errorData;\n            }\n          }\n\n          return null;\n        }\n\n        return null;\n      };\n    }\n\n    static validatorFn(validation, validator) {\n      return control => {\n        const validationErrors = validator(control);\n\n        if (validationErrors) {\n          let errorMessage = ValidationService.getErrorMessage(validation, control, validationErrors);\n          let errorData = {};\n          errorData[validation.name] = {\n            validationErrors,\n            errorMessage: errorMessage\n          };\n          return errorData;\n        }\n\n        return null;\n      };\n    }\n\n    static emailValidator(control) {\n      // RFC 2822 compliant regex\n      if (control.value.match(/[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?/)) {\n        return null;\n      } else {\n        return {\n          'invalidEmailAddress': true\n        };\n      }\n    }\n\n    static passwordValidator(control) {\n      // {6,100}           - Assert password is between 6 and 100 characters\n      // (?=.*[0-9])       - Assert a string has at least one number\n      if (control.value.match(/^(?=.*[0-9])[a-zA-Z0-9!@#$%^&*]{6,100}$/)) {\n        return null;\n      } else {\n        return {\n          'invalidPassword': true\n        };\n      }\n    }\n\n    MustMatch(controlName, matchingControlName) {\n      return formGroup => {\n        const control = formGroup.controls[controlName];\n        const matchingControl = formGroup.controls[matchingControlName];\n\n        if (matchingControl.errors && !matchingControl.errors.mustMatch) {\n          // return if another validator has already found an error on the matchingControl\n          return;\n        } // set error on matchingControl if validation fails\n\n\n        if (control.value !== matchingControl.value) {\n          matchingControl.setErrors({\n            mustMatch: true\n          });\n        } else {\n          matchingControl.setErrors(null);\n        }\n      };\n    }\n\n    getValidations(controlName, validationData) {\n      return validationData.find(v => v.controlName === controlName).validations;\n    }\n\n    getValidationsFromArray(formarrayName, controlName, validationData) {\n      return validationData.find(v => v.controlName === formarrayName).controls.find(c => c.controlName == controlName).validations;\n    }\n\n    static getErrorMessage(validation, control, validationErrors, formFroup) {\n      let message = validation.defaultMessage;\n\n      if (validation.message) {\n        if (validation.message.value) {\n          message = validation.message.value;\n        }\n\n        if (!validation.message.isStatic && message && validation.message.dynamicParams) {\n          validation.message.dynamicParams.forEach(element => {\n            const regexp = new RegExp(element.field, 'g');\n            let controlValue = '';\n            eval(`controlValue = ${element.value}`);\n            message = message.replace(regexp, controlValue);\n          });\n        }\n      }\n\n      return message;\n    }\n\n  }\n\n  ValidationService.ɵfac = function ValidationService_Factory(t) {\n    return new (t || ValidationService)(i0.ɵɵinject(i1.FormBuilder));\n  };\n\n  ValidationService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: ValidationService,\n    factory: ValidationService.ɵfac,\n    providedIn: 'root'\n  });\n  return ValidationService;\n})();","map":null,"metadata":{},"sourceType":"module"}